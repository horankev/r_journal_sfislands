# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit article.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.align = "center")

# install.packages("devtools")
# devtools::install_github("horankev/sfislands")

# required libraries
library(tidyverse)
library(kableExtra)
library(sf)
library(sfdep)
library(sfislands)
library(mgcv)
library(here)
library(ggsflabel)
library(ggspatial)
library(ggpubr)
library(AER) # to test for overdispersion
library(ggmagnify)

# To scrape data
library(rvest)
library(httr)
library(polite)
library(janitor)

# for geom_sf_label_repel consistency
set.seed(123)

# set consistent theme
theme_set(
  theme_bw() +
    theme(panel.background = element_rect(fill = "#F6F3E9", colour = "black", linewidth=1.5), 
          axis.title = element_blank(),
          axis.ticks = element_blank())
)



## -----------------------------------------------------------------------------
# load data

# datasets are all available at https://github.com/horankev/quake_data 
# or https://github.com/horankev/london_liverpool_data
# alongside details on precisely how they were sourced etc

# indonesia
quakes_df <- readRDS(gzcon(url("https://github.com/horankev/quake_data/raw/main/datasets/quakes_df.rds")))
provinces_df <- readRDS(gzcon(url("https://github.com/horankev/quake_data/raw/main/datasets/provinces_df.rds"))) |> 
  rename(damaging_quakes_total = quake_mlxl_total,
         damaging_quakes_density = quake_mlxl_density)
counties_df <- readRDS(gzcon(url("https://github.com/horankev/quake_data/raw/main/datasets/counties_df.rds")))
faults_df <- readRDS(gzcon(url("https://github.com/horankev/quake_data/raw/main/datasets/faults_df.rds")))
nearby_countries_df <- readRDS(gzcon(url("https://github.com/horankev/quake_data/raw/main/datasets/nearby_countries_df.rds")))
indonesia_outline <- provinces_df |> summarise()

# london
london <- readRDS(gzcon(url("https://github.com/horankev/london_liverpool_data/raw/main/data/london.rds")))
thames <- readRDS(gzcon(url("https://github.com/horankev/london_liverpool_data/raw/main/data/thames.rds")))
crossings_roadped <- readRDS(gzcon(url("https://github.com/horankev/london_liverpool_data/raw/main/data/crossings_roadped.rds")))

# liverpool
liverpool <- readRDS(gzcon(url("https://github.com/horankev/london_liverpool_data/raw/main/data/liverpool.rds")))
msoa_sf <- liverpool |> 
  group_by(msoa_cd) |> 
  summarise()
lsoa_sf <- liverpool |> 
  group_by(lsoa_cd) |> 
  summarise()
mersey <- readRDS(gzcon(url("https://github.com/horankev/london_liverpool_data/raw/main/data/mersey.rds")))




## -----------------------------------------------------------------------------
prefunc <- tribble(
  ~`function`, ~purpose,
  "st_bridges()", "create a neighbourhood contiguity structure, with a k-nearest neighbours condition for islands",
  "st_quickmap_nb()", "check structure visually on map",
  "st_check_islands()", "check the contiguities which have been assigned to islands",
  "st_manual_join_nb()", "make manual changes by adding connections",
  "st_manual_cut_nb()", "make manual changes by removing connections"
)



## ----prefunc-html, eval = knitr::is_html_output(), layout = "center"----------
#> knitr::kable(prefunc, format = "html", caption = "Pre-functions: setting up a neighbourhood structure.") |>
#>   kable_styling(full_width = TRUE)


## ----prefunc-latex, eval = knitr::is_latex_output()---------------------------
knitr::kable(prefunc, format = "latex", caption = "Pre-functions: setting up a neighbourhood structure.") |> 
  row_spec(0, bold = TRUE) |> 
  kableExtra::kable_styling(font_size = 9) |> 
  column_spec(2, width = "7cm")


## -----------------------------------------------------------------------------
rect1 <- st_polygon(list(rbind(c(0, 0), c(0, 2), c(2, 2), c(2, 0), c(0, 0))))
rect2 <- st_polygon(list(rbind(c(2, 0), c(2, 2), c(4, 2), c(4, 0), c(2, 0))))
rect3 <- st_polygon(list(rbind(c(2, 2), c(2, 4), c(4, 4), c(4, 2), c(2, 2))))
rect4 <- st_polygon(list(rbind(c(5, 0), c(5, 1), c(6, 1), c(6, 0), c(5, 0))))
rect5 <- st_polygon(list(rbind(c(0.8, 3), c(0.8, 4), c(1.8, 4), c(1.8, 3), c(0.8, 3))))

# Create sf objects for each rectangle
rect1_sf <- st_sf(geometry = st_sfc(rect1))
rect2_sf <- st_sf(geometry = st_sfc(rect2))
rect3_sf <- st_sf(geometry = st_sfc(rect3))
rect4_sf <- st_sf(geometry = st_sfc(rect4))
rect5_sf <- st_sf(geometry = st_sfc(rect5))

# Combine the rectangles into one sf object
rectangles <- rbind(rect1_sf, rect2_sf, rect3_sf, rect4_sf, rect5_sf) |> 
  mutate(name = c("Rect1","Rect2","Rect3","Rect4","Rect5"))


## ---- rects1, fig.width=4, fig.height=2, fig.cap = "Simplified scenario with five rectangles. "----
ggplot(rectangles) + geom_sf(colour="black", linewidth=1) + geom_sf_label(aes(label=name),size=2.5) + 
  coord_sf(datum=NA) + 
  theme(axis.title = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5))




## ---- echo=TRUE---------------------------------------------------------------
# output a named list

st_bridges(rectangles, 
           "name", 
           remove_islands = TRUE, 
           nb_structure = "list", 
           add_to_dataframe = FALSE) |>
  head()



## ---- echo=TRUE---------------------------------------------------------------
# output a named matrix

st_bridges(rectangles, 
           "name", 
           remove_islands = TRUE, 
           nb_structure = "matrix", 
           add_to_dataframe = FALSE) |> 
  head()



## ---- echo=TRUE---------------------------------------------------------------
# output a named list as a column "nb" in original dataframe

st_bridges(rectangles, 
           "name", 
           link_islands_k = 1, 
           nb_structure = "list") |> 
  head()



## ---- echo=TRUE---------------------------------------------------------------
# output a named matrix as a column "nb" in original dataframe

st_bridges(rectangles, 
           "name", 
           link_islands_k = 1, 
           nb_structure = "matrix") |> 
  head()



## ---- rects2, fig.width=2, fig.height=1, echo=TRUE, fig.cap = "Queen contiguity and islands connected to nearest neighbour. "----
# default is 'nodes = "point"'

st_bridges(rectangles, 
           "name", 
           link_islands_k = 1) |> 
  st_quickmap_nb()



## ---- rects3, fig.width=2, fig.height=1, echo=TRUE, fig.cap = "Queen contiguity and islands connected to nearest neighbour. Nodes are shown as numeric indices. "----
# with 'nodes = "numeric"'

st_bridges(rectangles, 
           "name", 
           link_islands_k = 1) |> 
  st_quickmap_nb(nodes = "numeric")



## ---- echo=TRUE---------------------------------------------------------------
# show summary of non-contiguous connections in a dataframe

st_bridges(rectangles, 
           "name", 
           link_islands_k = 1) |> 
  st_check_islands()



## ---- rects4, fig.width=2, fig.height=1, echo=TRUE, fig.cap = "With an additional connection between 3 and 4. "----
# add an extra connection using numeric index

st_bridges(rectangles, "name", 
           link_islands_k = 1) |> 
  st_manual_join_nb(3,4) |> 
  st_quickmap_nb(nodes = "numeric")


## ---- rects5, fig.width=2, fig.height=1, echo=TRUE, fig.cap = "With an additional connection between 1 and 2. "----
# remove an existing connection using unit name, not index

st_bridges(rectangles, "name", 
           link_islands_k = 1) |> 
  st_manual_join_nb(3,4) |> 
  st_manual_cut_nb("Rect1","Rect2") |> 
  st_quickmap_nb(nodes = "numeric")


## -----------------------------------------------------------------------------
postfunc <- tribble(
  ~`function`, ~purpose,
  "st_augment()", "augment the original dataframe with model predictions",
  "st_quickmap_preds()", "generate quick maps of these predictions"
)



## ----postfunc-html, eval = knitr::is_html_output(), layout = "center"---------
#> knitr::kable(postfunc, format = "html", caption = "Post-functions: tidy estimates from `mgcv`.") |>
#>   kable_styling(full_width = TRUE)


## ----postfunc-latex, eval = knitr::is_latex_output()--------------------------
knitr::kable(postfunc, format = "latex", caption = "Post-functions: tidy estimates from mgcv.") |> 
  row_spec(0, bold = TRUE) |> 
  kableExtra::kable_styling(font_size = 9, full_width = FALSE)


## ---- eval=FALSE, echo=TRUE---------------------------------------------------
#> # creating an mgcv model
#> 
#> mgcv::gam(
#>   y ~ covariate +                   # fixed intercept and effect for covariate
#>     s(region, bs = "re") +                  # random intercept at level region
#>     s(region, covariate, bs = "re") +          # random slopes at level region
#>     s(sub-region,
#>       bs = 'mrf',
#>       xt = list(nb = data$nb),
#>       k = k) +                    # ICAR varying intercept at level sub-region
#>     s(sub-region, by = covariate,
#>       bs = 'mrf',
#>       xt = list(nb = data$nb),
#>       k = k),           # ICAR varying slope for covariate at level sub-region
#>   data = data,
#>   method = "REML")


## -----------------------------------------------------------------------------
st_aug_tab_html <- tribble(
  ~`mgcv syntax`, ~`column name`,
  "s(region, bs = 're')", "random.effect.region",
  "s(region, covariate, bs = 're')", "random.effect.covariate|region",
  "s(sub-region, bs = 'mrf', xt = list(nb = data\\$nb)", "mrf.smooth.sub-region",
  "s(sub-region, by = covariate, bs = 'mrf', xt = list(nb = data\\$nb)", "mrf.smooth.covariate|sub-region"
)


## -----------------------------------------------------------------------------
st_aug_tab_latex <- tribble(
  ~`mgcv syntax`, ~`column name`,
  "s(region, bs = 're')", "random.effect.region",
  "s(region, covariate, bs = 're')", "random.effect.covariate|region",
  "s(sub-region, bs = 'mrf', xt = list(nb = data$nb)", "mrf.smooth.sub-region",
  "s(sub-region, by = covariate, bs = 'mrf', xt = list(nb = data$nb)", "mrf.smooth.covariate|sub-region"
)


## ----staugtab-html, eval = knitr::is_html_output(), layout = "center"---------
#> knitr::kable(st_aug_tab_html, format = "html", caption = "The naming procedure for augmented columns from different `mgcv` structures.") |>
#>   kable_styling(full_width = TRUE)


## ----staugtab-latex, eval = knitr::is_latex_output()--------------------------
knitr::kable(st_aug_tab_latex, format = "latex", caption = "The naming procedure for augmented columns from different mgcv structures.") |> 
  row_spec(0, bold = TRUE) |> 
  kableExtra::kable_styling(font_size = 9, full_width = FALSE, )


## ---- fault-buffers, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Indonesia faults. Surrounded by a 10 kilometre buffer. "----

faults_buf <- faults_df |> 
  st_buffer(dist = 10000)

ggplot() + 
  geom_sf(data=nearby_countries_df, fill="gray50", linewidth=0.5, colour="black") +
  geom_sf(data = provinces_df, fill="antiquewhite", colour="black",linewidth=0.5) +
  geom_sf(data = faults_buf, fill="darkgreen", colour="gray50",linewidth=0.9) +
  geom_sf(data=faults_df, colour="yellow", linewidth=0.4) +
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5),
        axis.title = element_blank(),
        axis.ticks = element_blank())



## ---- fault-conc, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Indonesia fault concentration. Square kilometre of buffered fault per square kilometre of province area. "----

ggplot() + 
  geom_sf(data=nearby_countries_df, fill="gray50", colour="black", linewidth=0.5) +
  geom_sf(data=provinces_df, aes(fill=fault_concentration), colour="black", linewidth=0.5) +
  geom_sf(data=faults_df, colour="gray10", linetype="dashed", linewidth=0.5) +
  scale_fill_distiller(palette = "YlGn", direction = 1) + 
  labs(fill="fault\nconcentration") + 
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5),
        legend.position = c(0.92,0.8),
        legend.box.background = element_rect(colour = "black", linewidth = 1))



## ---- quake-occur, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Earthquakes in Indonesia of magnitude > 5.5, 1985-2023. Categorised by magnitude as medium, large or extra-large. "----

quakes_df_temp <- quakes_df |> 
  mutate(magfact = case_when(magfact == "M" ~ "M: 5.5 - 6",
                             magfact == "L" ~ "L: 6.1 - 6.9",
                             magfact == "XL" ~ "XL: 7+")) |> 
  mutate(magfact = factor(magfact,
                          levels = c("M: 5.5 - 6",
                                     "L: 6.1 - 6.9",
                                     "XL: 7+")))
ggplot() + 
  geom_sf(data=nearby_countries_df, fill="gray50", linewidth=0.5, colour="black") +
  geom_sf(data=provinces_df, fill="antiquewhite", colour="black", linewidth=0.5) + 
  geom_sf(data=quakes_df_temp |> filter(magfact != "S") |> filter(province != "undersea"), 
          aes(fill=magfact, size=magfact), shape=21, colour="black") +
  scale_fill_manual(values = c("white","khaki","tomato4")) +
  scale_size_manual(values = c(3.5,5.5,7.5)) + 
  labs(fill="magnitude",
       size="magnitude") + 
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5),
        legend.position = c(0.92,0.8),
        legend.key = element_blank(),
        legend.box.background = element_rect(colour = "black", linewidth = 1))



## ---- quake-totals, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Earthquake count in Indonesia, 1985-2023, mag > 5.5: count by province. "----

ggplot() +
  geom_sf(data=nearby_countries_df, fill="gray50", colour="black", linewidth=0.5) +
  geom_sf(data=provinces_df, aes(fill=damaging_quakes_total), colour="black", linewidth=0.5) +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) + 
  labs(fill="count") + 
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5),
        legend.position = c(0.92,0.78),
        legend.box.background = element_rect(colour = "black", linewidth = 1))
  


## ---- quake-conc, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Earthquake incidence in Indonesia, 1985-2023, mag > 5.5: count per square kilometre by province. "----

  ggplot() +
  geom_sf(data=nearby_countries_df, fill="gray50", colour="black", linewidth=0.5) +
  geom_sf(data=provinces_df, aes(fill=damaging_quakes_density), colour="black", linewidth=0.5) +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) + 
  labs(fill="incidence") + 
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5),
  axis.title = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.92,0.78),
        legend.box.background = element_rect(colour = "black", linewidth = 1))



## ---- ind-contig1, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption1)"----
# join islands to k=2 nearest neighbours
# various arguments exist for altering colours and sizes
# additional ggplot themes and layers can be added

st_bridges(provinces_df, "province",link_islands_k = 2) |> 
  st_quickmap_nb(fillcol = "antiquewhite1", 
                 bordercol = "black", bordersize = 0.5, 
                 linkcol = "darkblue", linksize = 0.8, 
                 pointcol = "red", pointsize = 2) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()) +
  geom_sf(data=nearby_countries_df, 
          fill="gray50", linewidth=0.5, colour="black")



## ---- ind-contig1html, fig.width=12, fig.height=6, echo=FALSE, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Neighbourhood structure for Indonesian provinces created by st_bridges() with k=2. "----
#> # join islands to k=2 nearest neighbours
#> # various arguments exist for altering colours and sizes
#> # additional ggplot themes and layers can be added
#> 
#> st_bridges(provinces_df, "province",link_islands_k = 2) |>
#>   st_quickmap_nb(fillcol = "antiquewhite1",
#>                  bordercol = "black", bordersize = 0.5,
#>                  linkcol = "darkblue", linksize = 0.8,
#>                  pointcol = "red", pointsize = 2) +
#>   theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black",
#>                                         linewidth=1.5),
#>         axis.text = element_blank()) +
#>   geom_sf(data=nearby_countries_df,
#>           fill="gray50", linewidth=0.5, colour="black")
#> 


## ---- ind-contig2, fig.width=12, fig.height=6, echo=FALSE, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption2)"----
# with 'concavehull = TRUE' and 'nodes = "numeric"'

st_bridges(provinces_df, "province",link_islands_k = 2) |> 
  st_quickmap_nb(fillcol = "antiquewhite1", 
                 bordercol = "black", bordersize = 0.5, 
                 linkcol = "tomato", linksize = 0.5, 
                 nodes = "numeric", 
                 numericcol = "black", numericsize = 6, 
                 concavehull = TRUE, 
                 hullcol = "darkgreen", hullsize = 0.2) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank())



## ---- ind-contig2html, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Neighbourhood structure for Indonesian provinces. Viewed with st\\_quickmap_nb(), using the arguments nodes = 'numeric' and concavehull = TRUE. "----
#> # with 'concavehull = TRUE' and 'nodes = "numeric"'
#> 
#> st_bridges(provinces_df, "province",link_islands_k = 2) |>
#>   st_quickmap_nb(fillcol = "antiquewhite1",
#>                  bordercol = "black", bordersize = 0.5,
#>                  linkcol = "tomato", linksize = 0.5,
#>                  nodes = "numeric",
#>                  numericcol = "black", numericsize = 6,
#>                  concavehull = TRUE,
#>                  hullcol = "darkgreen", hullsize = 0.2) +
#>   theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black",
#>                                         linewidth=1.5),
#>         axis.text = element_blank())
#> 


## ---- ind-contig3, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption3)"----
# a series of manual joins and cuts by index number

st_bridges(provinces_df, "province",link_islands_k = 2) |> 
  st_manual_join_nb(1,24) |> 
  st_manual_join_nb(1,30) |> 
  st_manual_join_nb(3,13) |> 
  st_manual_join_nb(13,17) |> 
  st_manual_join_nb(14,25) |> 
  st_manual_join_nb(20,29) |>
  st_manual_join_nb(19,23) |> 
  st_manual_join_nb(16,27) |> 
  st_manual_join_nb(22,23) |> 
  st_manual_join_nb(7,19) |> 
  st_manual_join_nb(7,20) |>
  st_manual_join_nb(19,28) |> 
  st_manual_join_nb(4,18) |> 
  st_manual_join_nb(21,26) |> 
  st_manual_join_nb(22,28) |> 
  st_manual_cut_nb(19,22) |> 
  st_quickmap_nb(fillcol = "antiquewhite1", 
                 bordercol = "black", bordersize = 0.5, 
                 linkcol = "darkblue", linksize = 0.8, 
                 pointcol = "red", pointsize = 2) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()) +
  geom_sf(data=nearby_countries_df, 
          fill="gray50", linewidth=0.5, colour="black") + 
  annotation_scale()



## ---- ind-contig3html, fig.width=12, fig.height=6, echo=FALSE, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Neighbourhood structure for Indonesian provinces, after alterations using st\\_manual_join() and st\\_manual_cut(). "----
#> # a series of manual joins and cuts by index number
#> 
#> st_bridges(provinces_df, "province",link_islands_k = 2) |>
#>   st_manual_join_nb(1,24) |>
#>   st_manual_join_nb(1,30) |>
#>   st_manual_join_nb(3,13) |>
#>   st_manual_join_nb(13,17) |>
#>   st_manual_join_nb(14,25) |>
#>   st_manual_join_nb(20,29) |>
#>   st_manual_join_nb(19,23) |>
#>   st_manual_join_nb(16,27) |>
#>   st_manual_join_nb(22,23) |>
#>   st_manual_join_nb(7,19) |>
#>   st_manual_join_nb(7,20) |>
#>   st_manual_join_nb(19,28) |>
#>   st_manual_join_nb(4,18) |>
#>   st_manual_join_nb(21,26) |>
#>   st_manual_join_nb(22,28) |>
#>   st_manual_cut_nb(19,22) |>
#>   st_quickmap_nb(fillcol = "antiquewhite1",
#>                  bordercol = "black", bordersize = 0.5,
#>                  linkcol = "darkblue", linksize = 0.8,
#>                  pointcol = "red", pointsize = 2) +
#>   theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black",
#>                                         linewidth=1.5),
#>         axis.text = element_blank()) +
#>   geom_sf(data=nearby_countries_df,
#>           fill="gray50", linewidth=0.5, colour="black") +
#>   annotation_scale()
#> 


## ---- fig.width=12, fig.height=6----------------------------------------------

provinces_df$province <- factor(provinces_df$province)

prep_data <- st_bridges(provinces_df, "province",link_islands_k = 2) |> 
  st_manual_join_nb(1,24) |> 
  st_manual_join_nb(1,30) |> 
  st_manual_join_nb(3,13) |> 
  st_manual_join_nb(13,17) |> 
  st_manual_join_nb(14,25) |> 
  st_manual_join_nb(20,29) |>
  st_manual_join_nb(19,23) |> 
  st_manual_join_nb(16,27) |> 
  st_manual_join_nb(22,23) |> 
  st_manual_join_nb(7,19) |> 
  st_manual_join_nb(7,20) |>
  st_manual_join_nb(19,28) |> 
  st_manual_join_nb(4,18) |> 
  st_manual_join_nb(21,26) |> 
  st_manual_join_nb(22,28) |> 
  st_manual_cut_nb(19,22)



## ---- echo=TRUE---------------------------------------------------------------

mod_pois_mrf <- gam(damaging_quakes_total ~ 
                      fault_concentration +
                      s(province, bs='mrf', xt=list(nb=prep_data$nb), k=24) +
                      offset(log(area_province)),
                    data=prep_data, method="REML",family = "poisson")



## -----------------------------------------------------------------------------
summary(mod_pois_mrf)


## ---- eval=FALSE--------------------------------------------------------------
#> 
#> # these two are equivalent
#> AER::dispersiontest(mod_pois_mrf)
#> # AER::dispersiontest(mod_pois_mrf,trafo = 1)
#> 
#> # these two are equivalent
#> # AER::dispersiontest(mod_pois_mrf,trafo = function(x) x^2)
#> # AER::dispersiontest(mod_pois_mrf,trafo = 2)
#> 


## ---- echo=TRUE---------------------------------------------------------------
# column names of augmented dataframe

mod_pois_mrf |> 
  st_augment(prep_data) |> 
  names()


## ---- ind-mrf1, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption4)"----
# st_quickmap_preds() outputs a list of ggplots

plot_mrf <- mod_pois_mrf |> 
  st_augment(prep_data) |>
  st_quickmap_preds(scale_low = "darkgreen",
                    scale_mid = "ivory", 
                    scale_high = "darkred", 
                    scale_midpoint = 0)

# in this case, there is only one plot in the list
# so we call it by index
# it is then supplemented with additional ggplot functions

plot_mrf[[1]] +
  coord_sf(datum=NA) +
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()) +
  geom_sf(data=provinces_df, fill=NA, colour="black", linewidth=0.5) + 
  geom_sf(data=nearby_countries_df, fill="gray50", colour="black", 
          linewidth=0.5) + 
  labs(fill="relative\nincidence") +
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(legend.position = c(0.92,0.77),
        legend.box.background = element_rect(colour = "black", linewidth = 1),
        legend.title = element_text())



## ---- ind-mrf1html, fig.width=12, fig.height=6, echo=FALSE, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Estimates of $\\gamma_i$ using st_quickmap_preds(). "----
#> # st_quickmap_preds() outputs a list of ggplots
#> 
#> plot_mrf <- mod_pois_mrf |>
#>   st_augment(prep_data) |>
#>   st_quickmap_preds(scale_low = "darkgreen",
#>                     scale_mid = "ivory",
#>                     scale_high = "darkred",
#>                     scale_midpoint = 0)
#> 
#> # in this case, there is only one plot in the list
#> 
#> plot_mrf[[1]] +
#>   coord_sf(datum=NA) +
#>   theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black",
#>                                         linewidth=1.5),
#>         axis.text = element_blank()) +
#>   geom_sf(data=provinces_df, fill=NA, colour="black", linewidth=0.5) +
#>   geom_sf(data=nearby_countries_df, fill="gray50", colour="black",
#>           linewidth=0.5) +
#>   labs(fill="relative\nincidence") +
#>   annotation_scale() +
#>   coord_sf(datum=NA) +
#>   theme(legend.position = c(0.92,0.77),
#>         legend.box.background = element_rect(colour = "black", linewidth = 1),
#>         legend.title = element_text())
#> 


## ---- ind-mrf2, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption5)"----

qpois_mod_aug <- mod_pois_mrf |> 
  st_augment(prep_data)

largest <- qpois_mod_aug |> 
  arrange(desc(mrf.smooth.province)) |> 
  head(3)
smallest <- qpois_mod_aug |> 
  arrange(mrf.smooth.province) |> 
  head(2)

ggplot() + 
  geom_sf(data=nearby_countries_df, 
          fill="gray50", colour="black", linewidth=0.5) + 
  geom_sf(data=qpois_mod_aug, aes(fill=exp(mrf.smooth.province)), 
          colour="black", linewidth=0.5) + 
  geom_sf_label_repel(data=largest, 
                      aes(label=paste(province,":",
                                      round(exp(mrf.smooth.province),1))),
                      colour="darkred", size=2.5,
                      nudge_y= 300000) +
  geom_sf_label_repel(data=smallest |> mutate(geometry=st_centroid(geometry)), 
               aes(label=paste(province,":",round(exp(mrf.smooth.province),3))),
               nudge_y= 200000, colour="darkgreen", size=2.5) +
  scale_fill_gradient2(low = "darkgreen", 
                       mid = "ivory", 
                       high = "darkred", 
                       midpoint = 1) +
  scale_colour_gradient2(low = "darkgreen", 
                         mid = "ivory", 
                         high = "darkred", 
                         midpoint = 1) +
  guides(colour="none") + 
  labs(fill="exp.\nrelative\nincidence") + 
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5), 
        axis.title = element_blank(),
        axis.ticks = element_blank(), 
        legend.position = c(0.92,0.76),
        legend.box.background = element_rect(colour = "black", linewidth = 1))



## ---- ind-mrf2html, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Map showing estimates of exp($\\gamma_i$). This is produced by adding an additional column to the dataframe produced by st_augment()."----
#> 
#> qpois_mod_aug <- mod_pois_mrf |>
#>   st_augment(prep_data)
#> 
#> largest <- qpois_mod_aug |>
#>   arrange(desc(mrf.smooth.province)) |>
#>   head(3)
#> smallest <- qpois_mod_aug |>
#>   arrange(mrf.smooth.province) |>
#>   head(2)
#> 
#> ggplot() +
#>   geom_sf(data=nearby_countries_df,
#>           fill="gray50", colour="black", linewidth=0.5) +
#>   geom_sf(data=qpois_mod_aug, aes(fill=exp(mrf.smooth.province)),
#>           colour="black", linewidth=0.5) +
#>   geom_sf_label_repel(data=largest,
#>                       aes(label=paste(province,":",
#>                                       round(exp(mrf.smooth.province),1))),
#>                       colour="darkred", size=2.5,
#>                       nudge_y= 300000) +
#>   geom_sf_label_repel(data=smallest |> mutate(geometry=st_centroid(geometry)),
#>                aes(label=paste(province,":",round(exp(mrf.smooth.province),3))),
#>                nudge_y= 200000, colour="darkgreen", size=2.5) +
#>   scale_fill_gradient2(low = "darkgreen",
#>                        mid = "ivory",
#>                        high = "darkred",
#>                        midpoint = 1) +
#>   scale_colour_gradient2(low = "darkgreen",
#>                          mid = "ivory",
#>                          high = "darkred",
#>                          midpoint = 1) +
#>   guides(colour="none") +
#>   labs(fill="exp.\nrelative\nincidence") +
#>   annotation_scale() +
#>   coord_sf(datum=NA) +
#>   theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5),
#>         axis.title = element_blank(),
#>         axis.ticks = element_blank(),
#>         legend.position = c(0.92,0.76),
#>         legend.box.background = element_rect(colour = "black", linewidth = 1))
#> 


## ---- eval=FALSE, echo=TRUE---------------------------------------------------
#> # workflow:
#> 
#> # 1. set up neighbourhood structure
#> 
#> prep_data <- st_bridges(provinces_df, "province")
#> 
#> # 2. define model
#> 
#> mod <- gam(quake_mlxl_total ~
#>                   fault_concentration +
#>                   s(province, bs='mrf', xt=list(nb=prep_data$nb), k=22) +
#>                   offset(log(area_province)),
#>         data=prep_data, method="REML",family = "poisson")
#> 
#> # 3. augment tidy estimates
#> 
#> tidy_ests <- st_augment(mod, prep_data)
#> 
#> # 4. visualise them
#> 
#> st_quickmap_preds(tidy_ests)


## ---- lon-contig1, fig.width=12, fig.height=8, echo=TRUE, out.width="100%", fig.cap = "Wards and boroughs of Greater London. Queen contiguity. "----
# same as sfdep:st_contiguity() as there are no islands
# an extra layer for the river Thames

st_bridges(london, "NAME") |> 
  st_quickmap_nb() + 
  geom_sf(data=thames, colour="blue", linewidth=1.5) + 
  theme(panel.background = element_rect(fill = "#F6F3E9", colour = "black", 
                                        linewidth=1.5))



## ---- lon-contig2, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", fig.cap = "Riverside boroughs of Greater London. Queen contiguity disregarding river. "----
# which boroughs are alongside the river

riverside <- thames |> st_intersects(london) |> unlist() |> unique()

# only map these boroughs

st_bridges(london[riverside,],"NAME") |> 
  st_quickmap_nb(linksize = 0.5) +
  geom_sf(data=thames, colour="blue", linewidth=1.5) + 
  annotation_scale(location="br") +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F6F3E9", colour = "black", 
                                        linewidth=1.5))


## ---- lon-crossings, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Riverside boroughs of Greater London. Road and pedestrian crossing and tunnels surrounded by 1 kilometre buffer shaded green. "----

ggplot() + 
  geom_sf(data=london[riverside,], fill="gray90", colour="gray50", linewidth=0.5) + 
  geom_sf(data=crossings_roadped |> st_buffer(1000), fill="darkgreen", alpha=0.4) + 
  geom_sf(data=thames, colour="blue", linewidth=1.5) + 
  geom_sf(data=crossings_roadped, size=1, colour="yellow") + 
  geom_sf_label_repel(data=crossings_roadped[1:11,], aes(label=crossing), size=2.5, nudge_y=-10000, fill="white", fontface="bold") + 
  geom_sf_label_repel(data=crossings_roadped[12:22,], aes(label=crossing), size=2.5, nudge_y=10000, fill="white", fontface="bold") +
  annotation_scale(location="br") +
  coord_sf(datum=NA)



## -----------------------------------------------------------------------------
# which riverside units do not fall within any of the buffers...

crossing_buffer_summarised <- crossings_roadped |> 
  st_buffer(1000) |> 
  st_transform(st_crs(london)) |> 
  summarise()

touch_buffer <- st_intersects(london[riverside,],
                              crossing_buffer_summarised)
indices <- c()
for (i in seq_along(touch_buffer)) {
  if (length(touch_buffer[[i]]) == 0) {
    indices <- c(indices, i)
  }
}
indices <- which(sapply(touch_buffer, length) == 0)

no_touch_buffer <- london[riverside,][indices,]


## ---- lon-contig3, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", fig.cap = "Riverside boroughs of Greater London. Index number for each borough shown at centroid. Boroughs which are not within 1 kilometre of a crossing are shaded pink. "----
# with 'nodes = "numeric"'

st_bridges(london[riverside,],"NAME") |> 
  st_quickmap_nb(nodes = "numeric", numericsize = 4, linksize = 0.5) +
  geom_sf(data=no_touch_buffer, fill="pink", alpha=0.3) + 
  geom_sf(data=crossings_roadped |> st_buffer(1000), 
          fill="darkgreen", alpha=0.3) +
  geom_sf(data=thames, colour="blue", linewidth=1.5) + 
  geom_sf(data=crossings_roadped, size=1, colour="yellow") + 
  annotation_scale(location="br") +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F6F3E9", colour = "black", 
                                        linewidth=1.5))


## ---- lon-contig4, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", fig.cap = "Riverside boroughs of Greater London. Contiguities across the river have been cut for the pink boroughs. "----
# manually cut the links where there is no crossing

st_bridges(london[riverside,], "NAME") |> 
  st_manual_cut_nb(18,17) |> 
  st_manual_cut_nb(19,17) |> 
  st_manual_cut_nb(19,20) |> 
  st_manual_cut_nb(20,21) |> 
  st_manual_cut_nb(21,22) |> 
  st_manual_cut_nb(22,48) |> 
  st_manual_cut_nb(47,48) |> 
  st_manual_cut_nb(45,46) |> 
  st_manual_cut_nb(45,47) |>  
  st_manual_cut_nb(39,65) |> 
  st_manual_cut_nb(1,2) |> 
  st_quickmap_nb(bordercol = "black", bordersize = 0.5, linksize = 0.5) +
  geom_sf(data=no_touch_buffer, fill = "pink", alpha = 0.3) + 
  geom_sf(data=crossings_roadped |> st_buffer(1000), 
          fill= "darkgreen", alpha = 0.3) +
  geom_sf(data=thames, colour = "blue", linewidth = 1.5) +
  annotation_scale(location = "br") +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F6F3E9", colour = "black", 
                                        linewidth = 1.5))


## -----------------------------------------------------------------------------
livadmin <- tribble(
  ~code, ~`area type`, ~description,
  "OA", "output areas", "lowest level of geographical area for census statistics, usually containing 100 - 625 persons",
  "LSOA", "lower layer super output areas", "usually 4 or 5 OAs",
  "MSOA", "middle layer super output areas", "usually 4 or 5 LSOAs"
)



## ----livadmin-html, eval = knitr::is_html_output(), layout = "center"---------
#> knitr::kable(livadmin, format = "html", caption = "Three nested levels of administrative divisions in Liverpool.") |>
#>   kable_styling(full_width = TRUE)


## ----livadmin-latex, eval = knitr::is_latex_output()--------------------------
knitr::kable(livadmin, format = "latex", caption = "Three nested levels of administrative divisions in Liverpool.") |> 
  row_spec(0, bold = TRUE) |> 
  kableExtra::kable_styling(font_size = 8) |> 
  column_spec(3, width = "7cm")


## ---- liv-nested, fig.width=10, fig.height=5, out.width="100%", fig.cap = "Nested levels of administrative divisions in Liverpool. "----

ggarrange(
  ggplot() + 
    geom_sf(data=msoa_sf, fill="gray90", colour="black") +  
    geom_sf(data=mersey, fill="lightblue", colour="black", linewidth=0.2) + 
    geom_sf(data=liverpool |> summarise(), colour="black", fill=NA) + 
    labs(title = "level 1: MSOA polygons") + 
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F7FFF2", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()),
  
  ggplot() + 
    geom_sf(data=lsoa_sf, fill="gray90", colour="gray40") +  
    geom_sf(data=mersey, fill="lightblue", colour="black", linewidth=0.2) + 
    geom_sf(data=liverpool |> summarise(), colour="black", fill=NA) + 
    labs(title = "level 2: LSOA polygons") + 
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F7FFF2", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()),
  
  ggplot() + 
    geom_sf(data=liverpool |> summarise(), colour="black", fill="white") + 
    geom_sf(data=liverpool |> st_centroid(), 
            fill="gray90", colour="gray50", size=0.1) +  
    geom_sf(data=mersey, fill="lightblue", colour="black", linewidth=0.2) + 
    labs(title = "level 3: OA (shown as centroids)") + 
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F7FFF2", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()),
  
  ncol=3
)



## ---- liv-vars, fig.width=6, fig.height=4, out.width="70%", fig.cap = "Unemployment and limiting long-term illness rates in Liverpool, with extent of Mersey estuary in light blue to the south west. "----

ggarrange(
  ggplot() + 
    geom_sf(data=liverpool, aes(fill=unemployment, colour=unemployment)) + 
    geom_sf(data=liverpool |> summarise(), 
            fill=NA, colour="gray30", linewidth=0.2) +  
    geom_sf(data=mersey, fill="lightblue", colour="gray30", linewidth=0.2) + 
    scale_fill_distiller(palette = "PuBu", direction = 1) + 
    scale_colour_distiller(palette = "PuBu", direction = 1) + 
    labs(fill="unemployment",
         colour="unemployment") + 
    coord_sf(datum=NA) + 
    annotation_scale(location = "bl", width_hint = 0.4) +
    annotation_north_arrow(location = "bl", which_north = "true", 
        pad_x = unit(0.0, "in"), pad_y = unit(0.2, "in"),
        style = north_arrow_fancy_orienteering) +
    theme(panel.background = element_rect(fill = "#F7FFF2", colour = "black", 
                                          linewidth=0.6), 
          axis.title = element_blank(),
          axis.ticks = element_blank(),
          legend.text = element_text(size=8),
          legend.title = element_text(size=8)),
  ggplot() + 
    geom_sf(data=liverpool, aes(fill=lt_illness, colour=lt_illness)) + 
    geom_sf(data=liverpool |> summarise(), 
            fill=NA, colour="gray30", linewidth=0.2) +  
    geom_sf(data=mersey, fill="lightblue", colour="gray30", linewidth=0.2) + 
    scale_fill_distiller(palette = "RdYlBu", direction = -1) + 
    scale_colour_distiller(palette = "RdYlBu", direction = -1) + 
    labs(fill="limiting long-term\nillness\n(z-score)",
         colour="limiting long-term\nillness\n(z-score)") + 
    coord_sf(datum=NA) +
    annotation_scale(location = "bl", width_hint = 0.4) +
    annotation_north_arrow(location = "bl", which_north = "true", 
        pad_x = unit(0.0, "in"), pad_y = unit(0.2, "in"),
        style = north_arrow_fancy_orienteering) +
    theme(panel.background = element_rect(fill = "#F7FFF2", colour = "black", 
                                          linewidth=0.6), 
          axis.title = element_blank(),
          axis.ticks = element_blank(),
          legend.text = element_text(size=8),
          legend.title = element_text(size=8)),
  
  ncol=2, legend = "bottom"
)



## ---- liv-contigs, fig.width=5, fig.height=5, out.width="60%", echo=TRUE, fig.cap = "First order queen contiguity of output areas (OAs) in Liverpool with magnified inset. "----
# show st_bridges() connection with a magnified section

from <- c(xmin = -2.97, xmax = -2.95, ymin = 53.38, ymax = 53.39)
to <- c(-3.01,-2.96,53.32,53.35)

st_bridges(liverpool, "oa_cd") |> 
  st_quickmap_nb(pointsize = 0.1,
                 linksize = 0.1,
                 fillcol = "gray90") +  
  geom_sf(data=mersey, fill="lightblue", colour="gray30", 
          linewidth=0.2, alpha=0.5) + 
  geom_magnify(data=liverpool, 
               from = from, to = to, 
               corners = 0.1, shadow = TRUE, linewidth = 0.6) + 
  theme(panel.background = element_rect(fill = "#F7FFF2",
                                        colour = "black", linewidth=1))



## -----------------------------------------------------------------------------

# these models take a while to run
# so i am using a saved version of their output
# the files are large so are not on github
# uncomment the model and run it to reproduce

prepliv <- st_bridges(liverpool, "oa_cd")

# liverpool_model2 <- gam(unemployment ~ lt_illness + 
#                          s(msoa_cd, bs="re") + 
#                          s(msoa_cd, lt_illness, bs="re") +
#                          s(lsoa_cd, bs="re") + 
#                          s(lsoa_cd, lt_illness, bs="re"), # ICAR constituency ICAR varying coefficients
#                        data=prepliv, method="REML")

# saveRDS(liverpool_model2, here("data","liverpool_model2.rds"))

liverpool_hmodel <- readRDS(here("data","liverpool_model2.rds"))

# summary(liverpool_hmodel)



## -----------------------------------------------------------------------------

# these models take a while to run
# so i am using a saved version of their output
# the files are large so are not on github
# uncomment the model and run it to reproduce

# liverpool_hsamodel <- gam(unemployment ~ lt_illness +
#                          s(msoa_cd, bs="re") +
#                          s(msoa_cd, lt_illness, bs="re") +
#                          s(lsoa_cd, bs="re") +
#                          s(lsoa_cd, lt_illness, bs="re") +
#                          s(oa_cd, bs='mrf',
#                            xt=list(nb=prepliv$nb),k=20), # ICAR constituency ICAR varying coefficients
#                        data=prepliv, method="REML")

# saveRDS(liverpool_hsamodel, here("data","liverpool_hsamodel.rds")

liverpool_hsamodel <- readRDS(here("data","liverpool_hsamodel.rds"))

# summary(liverpool_hsamodel)



## -----------------------------------------------------------------------------

liverpool_hmodel_aug <- liverpool_hmodel |> 
  st_augment(prepliv) # pipe into function to get estimates

liverpool_hsamodel_aug <- liverpool_hsamodel |> 
  st_augment(prepliv) # pipe into function to get estimates



## -----------------------------------------------------------------------------

liverpool_hmodel_plots <- liverpool_hmodel |> 
  st_augment(prepliv) |> # pipe into function to get estimates
  st_quickmap_preds(borderwidth = NA, 
                    scale_low = "darkblue",
                    scale_mid = "gray75",
                    scale_high = "darkred",
                    scale_midpoint = 0, 
                    framefill = "#F7FFF2",
                    frameline = "black",
                    framesize = 1) # pipe into this for visualisation



## ---- liv-est1, fig.width=12, fig.height=3, out.width="100%", fig.cap = "Random intercept and slope estimates from hierarchical model. Middle and lower layer super output areas as levels. "----
# put an empty plot on the right to line up with those with an extra lowest level

ggarrange(
  plotlist = liverpool_hmodel_plots,
  nrow = 1, legend = "right"
)



## -----------------------------------------------------------------------------

liverpool_hsamodel_plots <- liverpool_hsamodel |> 
  st_augment(prepliv) |> # pipe into function to get estimates
  st_quickmap_preds(borderwidth = NA, 
                    # legendlimits = "minmax",
                    scale_low = "darkblue",
                    scale_mid = "gray75",
                    scale_high = "darkred",
                    scale_midpoint = 0, 
                    framefill = "#F7FFF2",
                    frameline = "black",
                    framesize = 1) # pipe into this for visualisation



## ---- liv-est2, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption6)"----

ggarrange(
  ggarrange(
    liverpool_hsamodel_plots[[1]],
    liverpool_hsamodel_plots[[2]],
    liverpool_hsamodel_plots[[3]],
    liverpool_hsamodel_plots[[4]],
    nrow = 1
  ),
  liverpool_hsamodel_plots[[5]],
  nrow = 2
)



## ---- liv-est2html, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Random intercept and slope estimates from hierarchical model. Middle and lower layer super output areas are the top two levels respectively (MSOA & LSOA). Output areas (OA) as lowest level Markov random field smooth using first-degree queen contiguity from st\\_bridges(). "----
#> 
#> ggarrange(
#>   ggarrange(
#>     liverpool_hsamodel_plots[[1]],
#>     liverpool_hsamodel_plots[[2]],
#>     liverpool_hsamodel_plots[[3]],
#>     liverpool_hsamodel_plots[[4]],
#>     nrow = 1
#>   ),
#>   liverpool_hsamodel_plots[[5]],
#>   nrow = 2
#> )
#> 


## -----------------------------------------------------------------------------

# 0.7km distance band
prepliv <- liverpool |> 
  mutate(nb = st_centroid(liverpool) |> 
              st_dist_band(upper = 0.7))
names(prepliv$nb) <- prepliv$oa_cd

# these models take a while to run
# so i am using a saved version of their output
# the files are large so are not on github
# uncomment the model and run it to reproduce

# liverpool_hsamodel_dist_band <- gam(unemployment ~ lt_illness +
#                          s(msoa_cd, bs="re") +
#                          s(msoa_cd, lt_illness, bs="re") +
#                          s(lsoa_cd, bs="re") +
#                          s(lsoa_cd, lt_illness, bs="re") +
#                          s(oa_cd, bs='mrf',
#                            xt=list(nb=prepliv$nb),k=20), # ICAR constituency ICAR varying coefficients
#                        data=prepliv, method="REML")

# saveRDS(liverpool_hsamodel_dist_band, here("data","liverpool_hsamodel_dist_band.rds"))

liverpool_hsamodel_dist_band <- readRDS(here("data","liverpool_hsamodel_dist_band.rds"))

# summary(liverpool_hsamodel_dist_band)



## -----------------------------------------------------------------------------

liverpool_hsamodel_dist_band_plots <- liverpool_hsamodel_dist_band |> 
  st_augment(prepliv) |> # pipe into function to get estimates
  st_quickmap_preds(borderwidth = NA, 
                    scale_low = "darkblue",
                    scale_mid = "gray75",
                    scale_high = "darkred",
                    scale_midpoint = 0, 
                    framefill = "#F7FFF2",
                    frameline = "black",
                    framesize = 1) # pipe into this for visualisation



## ---- liv-est3, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption7)"----

ggarrange(
  ggarrange(
    liverpool_hsamodel_dist_band_plots[[1]],
    liverpool_hsamodel_dist_band_plots[[2]],
    liverpool_hsamodel_dist_band_plots[[3]],
    liverpool_hsamodel_dist_band_plots[[4]],
    nrow = 1
  ),
  liverpool_hsamodel_dist_band_plots[[5]],
  nrow = 2
)



## ---- liv-est3html, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Random intercept and slope estimates from hierarchical model. Middle and lower layer super output areas are the top two levels respectively (MSOA & LSOA). Output areas (OA) as lowest level Markov random field smooth using sfdep\\:\\:st\\_dist_band() with radius of 700 metres."----
#> 
#> ggarrange(
#>   ggarrange(
#>     liverpool_hsamodel_dist_band_plots[[1]],
#>     liverpool_hsamodel_dist_band_plots[[2]],
#>     liverpool_hsamodel_dist_band_plots[[3]],
#>     liverpool_hsamodel_dist_band_plots[[4]],
#>     nrow = 1
#>   ),
#>   liverpool_hsamodel_dist_band_plots[[5]],
#>   nrow = 2
#> )
#> 


## -----------------------------------------------------------------------------

aic_tab <- AIC(liverpool_hmodel, liverpool_hsamodel, liverpool_hsamodel_dist_band) |> 
  data.frame() |> 
  mutate(`relative AIC` = round(-AIC / min(AIC),3),
         model = c("hierarchical model, no ICAR",
                   "hierarchical model, ICAR based on st_bridges()",
                   "hierarchical model, ICAR based on sfdep::st_dist_band()")) |> 
  rownames_to_column(var="modcode") |> 
  arrange(AIC) |> 
  select(model, AIC, `relative AIC`)



## ----aic-html, eval = knitr::is_html_output(), layout = "center"--------------
#> knitr::kable(aic_tab, format = "html", caption = "Comparison of models by AIC.") |>
#>   kable_styling(full_width = TRUE)


## ----aic-latex, eval = knitr::is_latex_output()-------------------------------
knitr::kable(aic_tab, format = "latex", caption = "Comparison of models by AIC.") |> 
  row_spec(0, bold = TRUE) |> 
  kableExtra::kable_styling(font_size = 8)

