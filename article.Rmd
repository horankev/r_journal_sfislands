---
title: "sfislands: An R Package for Accommodating Islands and Disjoint Zones in Areal Spatial Modelling"
date: "2022-11-09"
abstract: >
  Fitting areal spatial models can be a cumbersome task, particularly when the geographical units are not well-behaved. The presence of islands gives rise to particular issues when creating neighbourhood structures based on contiguity. We might also want to edit the output of a condition-based neighbourhood structure. It might be appropriate to add or remove connections to take account of infrastructure links or other domain-specific issues which are not apparent from a basic set of polygons. This package streamlines these processes with tools to account for the presence of islands and to intuitively make manual alterations to neighbourhood structures with the help of convenient mapping functions. Beyond the setting up of a satisfactory neighbourhood structure, it has further helper functions specific to the `mgcv` package which reduce the human workload required to extract estimates from models with spatial and hierarchical structures.
draft: true
author:  
  - name: Kevin Horan
    affiliation: 
    - Hamilton Institute, Maynooth University
    address:
    - Maynooth
    - Co. Kildare, Ireland
    url: https://github.com/horankev
    orcid: 0009-0003-9378-0084
    email:  kevin.horan.2021@mumail.ie
  - name: Katarina Domijan
    affiliation:
    - Department of Mathematics and Statistics, Maynooth University
    address:
    - Maynooth
    - Co. Kildare, Ireland
    email: katarina.domijan@mu.ie
    orcid: 0000-0002-4268-2236
  - name: Chris Brunsdon
    affiliation:
    - National Centre for Geocomputation, Maynooth University
    address:
    - Maynooth
    - Co. Kildare, Ireland
    email: Christopher.Brunsdon@mu.ie
    orcid: 0000-0003-4254-1780
type: package
output: 
  rjtools::rjournal_article:
    self_contained: yes
    toc: no
bibliography: RJreferences.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.align = "center")

# install.packages("devtools")
devtools::install_github("horankev/sfislands")

# required libraries
library(tidyverse)
library(kableExtra)
library(sf)
library(sfdep)
library(sfislands)
library(mgcv)
library(here)
library(ggsflabel)
library(ggspatial)
library(ggpubr)
library(AER) # to test for overdispersion
library(ggmagnify)

# To scrape data
library(rvest)
library(httr)
library(polite)
library(janitor)

# for geom_sf_label_repel consistency
set.seed(123)

# set consistent theme
theme_set(
  theme_bw() +
    theme(panel.background = element_rect(fill = "#F6F3E9", colour = "black", linewidth=1.5), 
          axis.title = element_blank(),
          axis.ticks = element_blank())
)

```

```{r}
# load data

# datasets are all available at https://github.com/horankev/quake_data 
# or https://github.com/horankev/london_liverpool_data
# alongside details on precisely how they were sourced etc

# indonesia
quakes_df <- readRDS(gzcon(url("https://github.com/horankev/quake_data/raw/main/datasets/quakes_df.rds")))
provinces_df <- readRDS(gzcon(url("https://github.com/horankev/quake_data/raw/main/datasets/provinces_df.rds"))) |> 
  rename(damaging_quakes_total = quake_mlxl_total,
         damaging_quakes_density = quake_mlxl_density)
counties_df <- readRDS(gzcon(url("https://github.com/horankev/quake_data/raw/main/datasets/counties_df.rds")))
faults_df <- readRDS(gzcon(url("https://github.com/horankev/quake_data/raw/main/datasets/faults_df.rds")))
nearby_countries_df <- readRDS(gzcon(url("https://github.com/horankev/quake_data/raw/main/datasets/nearby_countries_df.rds")))
indonesia_outline <- provinces_df |> summarise()

# london
london <- readRDS(gzcon(url("https://github.com/horankev/london_liverpool_data/raw/main/data/london.rds")))
thames <- readRDS(gzcon(url("https://github.com/horankev/london_liverpool_data/raw/main/data/thames.rds")))
crossings_roadped <- readRDS(gzcon(url("https://github.com/horankev/london_liverpool_data/raw/main/data/crossings_roadped.rds")))

# liverpool
liverpool <- readRDS(gzcon(url("https://github.com/horankev/london_liverpool_data/raw/main/data/liverpool.rds")))
msoa_sf <- liverpool |> 
  group_by(msoa_cd) |> 
  summarise()
lsoa_sf <- liverpool |> 
  group_by(lsoa_cd) |> 
  summarise()
mersey <- readRDS(gzcon(url("https://github.com/horankev/london_liverpool_data/raw/main/data/mersey.rds")))


```

# Introduction

A key feature which differentiates spatial statistics is the
non-independence of observations and the expectation that neighbouring
units will be more similar than non-neighbouring ones [@tobler]. If this
is not accounted for, the assumptions of many types of models will be
violated. The relationships between all spatial units in a study can be
represented numerically in a spatial weights matrix. In order to build
this, we must first decide on what constitutes being a neighbour. We can
see this as a continuous relationship where degree of neighbourliness is
a function of connectivity, which could be represented as some measure
of distance. Alternatively it could be a binary situation where each
pair of units either are (1) or are not (0) neighbours. This can be
based on a condition such as contiguity of some sort, or a distance
constraint. It is the job of the modeller to formulate a hypothesis
which justifies their choice of neighbourhood structure.

For R users, the \CRANpkg{spdep} package [@spdep] has long been popular for the
creation of these matrices. More recently, with the increasing use of \CRANpkg{sf}
structures and their compatibility with the \CRANpkg{tidyverse}  [@tidyverse], the \CRANpkg{sfdep}  [@sf] package [@sfdep] has presented the same
functionality in addition to extra features in a tidy structure based on
lists in a similar way to \CRANpkg{sf}.

The most appropriate form of neighbourhood structure will depend on the specific context. @BrizRedn2021 compared different structures in the context of COVID-19 data. They note that @Earnest2007 found that distance-based matrices were more appropriate when examining birth defects in Australia, whereas @Duncan2017 found that a first-order contiguity structure produced a better fit than others in the context of lip cancer incidence in Scotland.

The most commonly used neighbourhood structure is one based on first-order queen contiguity, where units are considered neighbours if they
share at least a vortex of boundary. However, as the name suggests, this
will lead to problems when non-contiguous units such as islands or
exclaves are present. Less obviously, depending on how the geographic
units are described, areas on either sides of rivers may be
inappropriately classified as neighbours or not neighbours. Furthermore,
the presence of infrastructure such as tunnels, bridges or ferry
services might be satisfactory to meet our hypothesis of the required
degree of connectivity to be considered neighbours.

The aim of `sfislands` is to deal with the situations described above in a
convenient and open manner. It allows us to set up a structure, quickly
map it, and then examine it. The structure can then be edited and the process re-iterated until we have described a
spatial relationship structure with which we are satisfied.

The above can be considered as the *pre-functions* of the package. A
further set of feature of `sfislands`, which we refer to as *post-functions*,
are for use with the \CRANpkg{mgcv} package [@mgcv]. It is straightforward to use
`sfislands` neighbourhood structures in models with \CRANpkg{mgcv} but it can be quite awkward
to extract the estimates. These *post-functions* conveniently provide the estimates in tidy format of random effects and intrinsic conditional autoregressive (ICAR) components from such models and give the ability to quickly map them for visualisation purposes.

## Typical use-cases

In this paper, we will look at three examples to show different use-cases for
`sfislands`. The first example focuses on earthquakes in
Indonesia. It shows a scenario where all of the functions are used, from
setting up contiguities to modelling and examining the estimates of the
model.

The second example looks at London and how, despite the lack of islands,
the presence of a river means that some of the pre-functions of
`sfislands` can be useful.

The final example focuses on Liverpool. There are no islands or issues
of discontiguity in this dataset. Instead, we will show how the package
can be used to fit a multilevel model with an ICAR component at the lowest
level. We show how the results can be presented in tidy form and quickly
visualised. We also show how different types of contiguity from the
\CRANpkg{sfdep} package can used within the \CRANpkg{mgcv} modelling
framework and how the estimates derived from them can be conveniently
compared.


# Why use `sfislands`?

It greatly speeds up the workflow of fitting areal spatial models.

* **pre-functions** for setting up contiguities:

  + it addresses an issue commonly seen in online help forums where an inexperienced user wishes to get started with a model but fails at the first hurdle because their neighbourhood structure is not compatible with their data. `sfislands` will include a contiguity for all units,

  + it gives tools to immediately visualise this structure as a map,

  + these maps are created using \CRANpkg{ggplot2}  [@ggplot2], which allows users to apply the desired styling and themes using \CRANpkg{ggplot2} syntax,

  + as the nodes can be labelled by index, it makes it very easy to add and remove connections as appropriate with confidence,

  + connections made by the package which are not contiguities can be accessed to ensure openness in the process.

* For modelling:

  + these neighbourhood structures can be used in modelling packages such as \CRANpkg{mgcv}, \CRANpkg{brms}. [@brms], \pkg{r-inla}  [@r-inla] and more.

* **post-functions** for `mgcv` models:

  + it simplifies the process of extracting estimates from models with random effects and Markov random field structures (ICAR models),

  + these effects can be quickly visualised in \CRANpkg{ggplot2} maps.

# Pre-functions

The first group of functions, shown in Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:prefunc-html)', '\\@ref(tab:prefunc-latex)'))`, deals with the creation
of a contiguity structure in the presence of discontiguities. The
resultant structure can be quickly mapped to check if it is
satisfactory. Connections can be manually added or removed by name or
index number. By an iterative process of changes and examination of a
quick map, a satisfactory structure can be decided upon.

Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:prefunc-html)', '\\@ref(tab:prefunc-latex)'))` shows these functions and their purpose.

```{r}
prefunc <- tribble(
  ~`function`, ~purpose,
  "st_bridges()", "create a neighbourhood contiguity structure, with a k-nearest neighbours condition for islands",
  "st_quickmap_nb()", "check structure visually on map",
  "st_check_islands()", "check the contiguities which have been assigned to islands",
  "st_manual_join_nb()", "make manual changes by adding connections",
  "st_manual_cut_nb()", "make manual changes by removing connections"
)

```

```{r prefunc-html, eval = knitr::is_html_output(), layout = "center"}
knitr::kable(prefunc, format = "html", caption = "Pre-functions: setting up a neighbourhood structure.") |> 
  kable_styling(full_width = TRUE)
```

```{r prefunc-latex, eval = knitr::is_latex_output()}
knitr::kable(prefunc, format = "latex", caption = "Pre-functions: setting up a neighbourhood structure.") |> 
  kableExtra::kable_styling(font_size = 9) |> 
  column_spec(2, width = "7cm")
```   

They deal with the creation
of a contiguity structure in the presence of discontiguities. The
resultant structure can be quickly mapped to check if it is
satisfactory. Connections can be manually added or removed by name or
index number. By an iterative process of changes and examination of a
quick map, a satisfactory structure can be decided upon.
Going through each function in more detail:

Use the rectangles shown in Figure \@ref(fig:rects1) as a simple demonstration. Rectangles 1-3
are contiguous while 4 and 5 are islands.

```{r}
rect1 <- st_polygon(list(rbind(c(0, 0), c(0, 2), c(2, 2), c(2, 0), c(0, 0))))
rect2 <- st_polygon(list(rbind(c(2, 0), c(2, 2), c(4, 2), c(4, 0), c(2, 0))))
rect3 <- st_polygon(list(rbind(c(2, 2), c(2, 4), c(4, 4), c(4, 2), c(2, 2))))
rect4 <- st_polygon(list(rbind(c(5, 0), c(5, 1), c(6, 1), c(6, 0), c(5, 0))))
rect5 <- st_polygon(list(rbind(c(0.8, 3), c(0.8, 4), c(1.8, 4), c(1.8, 3), c(0.8, 3))))

# Create sf objects for each rectangle
rect1_sf <- st_sf(geometry = st_sfc(rect1))
rect2_sf <- st_sf(geometry = st_sfc(rect2))
rect3_sf <- st_sf(geometry = st_sfc(rect3))
rect4_sf <- st_sf(geometry = st_sfc(rect4))
rect5_sf <- st_sf(geometry = st_sfc(rect5))

# Combine the rectangles into one sf object
rectangles <- rbind(rect1_sf, rect2_sf, rect3_sf, rect4_sf, rect5_sf) |> 
  mutate(name = c("Rect1","Rect2","Rect3","Rect4","Rect5"))
```


```{r, rects1, fig.width=4, fig.height=2, fig.cap = "Simplified scenario with five rectangles. "}
ggplot(rectangles) + geom_sf(colour="black", linewidth=1) + geom_sf_label(aes(label=name),size=2.5) + 
  coord_sf(datum=NA) + 
  theme(axis.title = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5))


```

## st_bridges()

This function requires as arguments an \CRANpkg{sf} dataframe and the name of a column of unique identifiers, preferably names, of each spatial unit. The k-nearest neighbours for connecting islands can then be specified. The output is a *named* neighbourhood structure in either list or matrix form as desired, which can be either a standalone object or included as an additional column in the original \CRANpkg{sf} dataframe. While it is not necessary in all modelling packages for the neighbourhood list or matrix to be *named*, it is good practice to do so and is mandatory when using, for example, \CRANpkg{mgcv}.

In the following examples, we have chosen to ignore islands with the argument `remove_islands = TRUE` and to return a list and matrix structure respectively by specifying this in the `nb_structure` argument and choosing `add_to_dataframe = FALSE`:

```{r, echo=TRUE}
# output a named list

st_bridges(rectangles, 
           "name", 
           remove_islands = TRUE, 
           nb_structure = "list", 
           add_to_dataframe = FALSE) |>
  head()

```

```{r, echo=TRUE}
# output a named matrix

st_bridges(rectangles, 
           "name", 
           remove_islands = TRUE, 
           nb_structure = "matrix", 
           add_to_dataframe = FALSE) |> 
  head()

```

In these examples, we choose to join islands to their 1 nearest
neighbour, which is the default setting, and to return the output as a column called "nb" in the original
\CRANpkg{sf} dataframe (this is the default setting):

```{r, echo=TRUE}
# output a named list as a column "nb" in original dataframe

st_bridges(rectangles, 
           "name", 
           link_islands_k = 1, 
           nb_structure = "list") |> 
  head()

```

```{r, echo=TRUE}
# output a named matrix as a column "nb" in original dataframe

st_bridges(rectangles, 
           "name", 
           link_islands_k = 1, 
           nb_structure = "matrix") |> 
  head()

```

These structures can serve as the input to models in \CRANpkg{brms},
\pkg{r-inla}, \pkg{rstan}  [@rstan] or \CRANpkg{mgcv}. Rather than having a separate neighbours
column, it is included as a named list or matrix in the original \CRANpkg{sf}
dataframe, in the spirit of the \CRANpkg{sfdep} package.

## st_quickmap_nb()

It is much more intuitive to examine these structures visually than in
matrix or list format. This can be done with the `st_quickmap_nb()`
function as shown in Figure \@ref(fig:rects2).

```{r, rects2, fig.width=2, fig.height=1, echo=TRUE, fig.cap = "Queen contiguity and islands connected to nearest neighbour. "}
# default is 'nodes = "point"'

st_bridges(rectangles, 
           "name", 
           link_islands_k = 1) |> 
  st_quickmap_nb()

```

If we wish to make edits, it might be more useful to represent the nodes
numerically rather than as points (Figure \@ref(fig:rects3)).

```{r, rects3, fig.width=2, fig.height=1, echo=TRUE, fig.cap = "Queen contiguity and islands connected to nearest neighbour. Nodes are shown as numeric indices. "}
# with 'nodes = "numeric"'

st_bridges(rectangles, 
           "name", 
           link_islands_k = 1) |> 
  st_quickmap_nb(nodes = "numeric")

```

## st_check_islands()

This function will tell us openly what connections have been made which
are not based on contiguity. It gives both the name and index number of each pair of added connections.

```{r, echo=TRUE}
st_bridges(rectangles, 
           "name", 
           link_islands_k = 1) |> 
  st_check_islands()

```

## st_manual_join_nb()

If we feel that 4 should also be connected to 3, this can be done
manually (Figure \@ref(fig:rects4)).

```{r, rects4, fig.width=2, fig.height=1, echo=TRUE, fig.cap = "With an additional connection between 3 and 4. "}
st_bridges(rectangles, "name", 
           link_islands_k = 1) |> 
  st_manual_join_nb(3,4) |> 
  st_quickmap_nb(nodes = "numeric")
```

## st_manual_cut_nb()

And perhaps there is a wide river between rectangles 1 and 2 which
justifies removing the connection. We will edit it this time using
names (Figure \@ref(fig:rects5)).

```{r, rects5, fig.width=2, fig.height=1, echo=TRUE, fig.cap = "With an additional connection between 1 and 2. "}
st_bridges(rectangles, "name", 
           link_islands_k = 1) |> 
  st_manual_join_nb(3,4) |> 
  st_manual_cut_nb("Rect1","Rect2") |> 
  st_quickmap_nb(nodes = "numeric")
```

The use of these structures is particularly common in CAR-type models.
These are often implemented in a Bayesian framework using
\CRANpkg{brms}, \pkg{r-inla} or \pkg{rstan}. The pre-functions will output the
neighbourhood structure in the desired format for use in any of these
frameworks. A convenient frequentist alternative is to use the
\CRANpkg{mgcv} package. It has the functionality to create such models
using `bs="mrf"`. It also has the ability to combine these with a
hierarchical structure using `bs="re"`. While the outputs from the
Bayesian structures mentioned above can be extracted in the same way as
any other component of the model, it can be a bit awkward to get the
estimates from \CRANpkg{mgcv} model. `sfislands` has two post-functions to conveniently extract and visualise these.

# Post-functions

Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:postfunc-html)', '\\@ref(tab:postfunc-latex)'))` shows the second set of functions in the package and their purpose.

```{r}
postfunc <- tribble(
  ~`function`, ~purpose,
  "st_augment()", "augment the original dataframe with model predictions",
  "st_quickmap_preds()", "generate quick maps of these predictions"
)

```

```{r postfunc-html, eval = knitr::is_html_output(), layout = "center"}
knitr::kable(postfunc, format = "html", caption = "Post-functions: tidy estimates from `mgcv`.") |> 
  kable_styling(full_width = TRUE)
```

```{r postfunc-latex, eval = knitr::is_latex_output()}
knitr::kable(postfunc, format = "latex", caption = "Post-functions: tidy estimates from mgcv.") |> 
  kableExtra::kable_styling(font_size = 9, full_width = FALSE)
```   

## st_augment()

This function augments the original dataframe with the estimated means
and standard errors from the \CRANpkg{mgcv} model in a similar manner to
how the \CRANpkg{broom}  [@broom] package operates. The `geometry` column, as per convention, remains as the last column of the augmented dataframe, while the new random effects columns are positioned immediately before it. The estimates which `st_augment()` will extract are random effects (which are called in \CRANpkg{mgcv} with `bs='re'`) and ICAR components (`bs='mrf'`). 

Consider the model structure described in the code below using \CRANpkg{mgcv} syntax. In this model $y$ is the dependent variable while it is being estimated with a fixed intercept, a fixed slope for some covariate, a random intercept and slope for the covariate at a *region* level, and an ICAR varying intercept and slope at a lower *sub-region* level.

```{r, eval=FALSE, echo=TRUE}
mgcv::gam(
  y ~ covariate +                   # fixed intercept and effect for covariate  
    s(region, bs = "re") +                  # random intercept at level region
    s(region, covariate, bs = "re") +          # random slopes at level region
    s(sub-region, 
      bs = 'mrf',
      xt = list(nb = data$nb), 
      k = k) +                    # ICAR varying intercept at level sub-region
    s(sub-region, by = covariate, 
      bs = 'mrf',
      xt = list(nb = data$nb), 
      k = k),           # ICAR varying slope for covariate at level sub-region
  data = data, 
  method = "REML")
```

When labelling the new columns which are augmented to the original dataframe from such a model, `st_augment()` follows the formula syntax of the \CRANpkg{lme4}  [@lme4] package, where the *pipe symbol* (`|`) indicates "*grouped by*". Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:staugtab-html)', '\\@ref(tab:staugtab-latex)'))` shows how the augmented columns in this scenario would be labelled. Each column name begins with either `random.effect.` or `mrf.smooth.` as appropriate. An additional column is also added for the standard error of each estimate. These columns are named as above but with `se.` prepended (e.g. `se.random.effect.region`).

```{r}
st_aug_tab_html <- tribble(
  ~`mgcv syntax`, ~`column name`,
  "s(region, bs = 're')", "random.effect.region",
  "s(region, covariate, bs = 're')", "random.effect.covariate|region",
  "s(sub-region, bs = 'mrf', xt = list(nb = data\\$nb)", "mrf.smooth.sub-region",
  "s(sub-region, by = covariate, bs = 'mrf', xt = list(nb = data\\$nb)", "mrf.smooth.covariate|sub-region"
)
```

```{r}
st_aug_tab_latex <- tribble(
  ~`mgcv syntax`, ~`column name`,
  "s(region, bs = 're')", "random.effect.region",
  "s(region, covariate, bs = 're')", "random.effect.covariate|region",
  "s(sub-region, bs = 'mrf', xt = list(nb = data$nb)", "mrf.smooth.sub-region",
  "s(sub-region, by = covariate, bs = 'mrf', xt = list(nb = data$nb)", "mrf.smooth.covariate|sub-region"
)
```

```{r staugtab-html, eval = knitr::is_html_output(), layout = "center"}
knitr::kable(st_aug_tab_html, format = "html", caption = "The naming procedure for augmented columns from different `mgcv` structures.") |> 
  kable_styling(full_width = TRUE)
```

```{r staugtab-latex, eval = knitr::is_latex_output()}
knitr::kable(st_aug_tab_latex, format = "latex", caption = "The naming procedure for augmented columns from different mgcv structures.") |> 
  kableExtra::kable_styling(font_size = 9, full_width = FALSE)
``` 

## st_quickmap_preds()

These estimates can then be quickly mapped. As it is possible to include more than 1 varying component, the output of this function is a list of plots. They can be viewed individually by indexing, or all at one using the `plotlist=` argument from the `ggarrange()` function which is part of the \CRANpkg{ggpubr}  [@ggpubr] package. We will see examples of this in the following examples. The maps are automatically titled and subtitled according to the type of effect. For example, the map showing `random.effect.region` will have "*region*" as its title and "*random.effect*" as its subtitle.

# Example 1: Indonesia

Modelling earthquakes in Indonesia seems like a good example to
demonstrate this package. Firstly, Indonesia is composed of many
islands. Secondly, earthquake activity is known to be associated with
the presence of faults which exist below sea level and thus do not
respect land boundaries. Therefore it is reasonable to expect similar
behaviour in nearby provinces regardless of whether or not they are
contiguous. We aim to model the intensity of earthquake activity by
province across Indonesia, controlling for proximity to faults.

## Data

The data for this section have been taken from the [USGS earthquake
catalogue API](https://earthquake.usgs.gov/earthquakes/search/). The
datasets and an explanation are available at
<https://github.com/horankev/quake_data> and record all earthquakes in
and close to Indonesia from 1985-2023. Below is a map of Indonesia, with
other neighbouring or bordering countries filled in grey. The many local
faults which lie within 300km of the shore are shown as green lines
in Figure \@ref(fig:fault-buffers).

```{r, fault-buffers, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Indonesia faults. Surrounded by a 10 kilometre buffer. "}

faults_buf <- faults_df |> 
  st_buffer(dist = 10000)

ggplot() + 
  geom_sf(data=nearby_countries_df, fill="gray50", linewidth=0.5, colour="black") +
  geom_sf(data = provinces_df, fill="antiquewhite", colour="black",linewidth=0.5) +
  geom_sf(data = faults_buf, fill="darkgreen", colour="gray50",linewidth=0.9) +
  geom_sf(data=faults_df, colour="yellow", linewidth=0.4) +
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5),
        axis.title = element_blank(),
        axis.ticks = element_blank())

```

To get an interpretable measure of the concentration of faults in any area
they are transformed from linestrings to polygons by setting a buffer of
10km around them, as shown below. Now both our faults and the sizes of provinces are in units of kilometres
squared. This means we can generate a unitless metric of what proportion of any administrative unit
is covered by these buffered faults. This measure across provinces is shown in Figure
\@ref(fig:fault-conc).

```{r, fault-conc, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Indonesia fault concentration. Square kilometre of buffered fault per square kilometre of province area. "}

ggplot() + 
  geom_sf(data=nearby_countries_df, fill="gray50", colour="black", linewidth=0.5) +
  geom_sf(data=provinces_df, aes(fill=fault_concentration), colour="black", linewidth=0.5) +
  geom_sf(data=faults_df, colour="gray10", linetype="dashed", linewidth=0.5) +
  scale_fill_distiller(palette = "YlGn", direction = 1) + 
  labs(fill="fault\nconcentration") + 
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5),
        legend.position = c(0.92,0.8),
        legend.box.background = element_rect(colour = "black", linewidth = 1))

```

Earthquake activity will be seen as the total number of earthquakes with
their epicentre in each province per unit area of that province. We have
restricted counts to earthquakes of magnitude \>5.5 which is the point
at which they are often labelled as damaging.

The occurrences of these earthquakes are shown in Figure \@ref(fig:quake-occur), their total per province in Figure \@ref(fig:quake-totals), and finally, their count per square kilometre can be seen in Figure \@ref(fig:quake-conc).

```{r, quake-occur, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Earthquakes in Indonesia, 1985-2023. Categorised as medium, large or extra-large. "}

ggplot() + 
  geom_sf(data=nearby_countries_df, fill="gray50", linewidth=0.5, colour="black") +
  geom_sf(data=provinces_df, fill="antiquewhite", colour="black", linewidth=0.5) + 
  geom_sf(data=quakes_df |> filter(magfact != "S") |> filter(province != "undersea"), 
          aes(fill=magfact, size=magfact), shape=21, colour="black") +
  scale_fill_manual(values = c("white","khaki","tomato4")) +
  scale_size_manual(values = c(3,5,7)) + 
  labs(fill="category",
       size="category") + 
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5),
        legend.position = c(0.92,0.8),
        legend.key = element_blank(),
        legend.box.background = element_rect(colour = "black", linewidth = 1))

```

```{r, quake-totals, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Earthquake count in Indonesia, 1985-2023, mag > 5.5: count by province. "}

ggplot() +
  geom_sf(data=nearby_countries_df, fill="gray50", colour="black", linewidth=0.5) +
  geom_sf(data=provinces_df, aes(fill=damaging_quakes_total), colour="black", linewidth=0.5) +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) + 
  labs(fill="count") + 
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5),
        legend.position = c(0.92,0.78),
        legend.box.background = element_rect(colour = "black", linewidth = 1))
  
```

```{r, quake-conc, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Earthquake incidence in Indonesia, 1985-2023, mag > 5.5: count per square kilometre by province. "}

  ggplot() +
  geom_sf(data=nearby_countries_df, fill="gray50", colour="black", linewidth=0.5) +
  geom_sf(data=provinces_df, aes(fill=damaging_quakes_density), colour="black", linewidth=0.5) +
  scale_fill_distiller(palette = "YlOrRd", direction = 1) + 
  labs(fill="incidence") + 
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5),
  axis.title = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.92,0.78),
        legend.box.background = element_rect(colour = "black", linewidth = 1))

```

## Model

As this is count data, we will model it as a poisson distribution with
$\lambda$ as the mean count per province. For $i = 1,...,n$ provinces,
the dependent variable in this model is
\begin{equation}
y_i = \text{earthquake incidence}_i = \frac{\text{earthquake count in province}_i} {\text{province area}_i}, 
(\#eq:eq1)
\end{equation}
while the explanatory variable is
\begin{equation}
x_i = \text{fault intensity}_i = \frac{\text{area of buffered faults in province}_i} {\text{province area}_i}.
(\#eq:eq2)
\end{equation}
Firstly, when excluding the incidence and just modelling counts, where
$y_i = \text{earthquake count in province}_i$, the poisson model is of
the following form: 
\begin{equation}
y_i | \lambda_i \sim \text{Pois}(\lambda_i)
(\#eq:eq3)
\end{equation}
with
\begin{equation}
E(y_i | \lambda_i) = \lambda_i.
(\#eq:eq4)
\end{equation}
We model
\begin{equation}
log(\lambda_i) = \beta_0 + \beta_1x_i + \gamma_i.
(\#eq:eq5)
\end{equation}
where $\gamma_i$
is a term with a correlation structure reflecting a province’s location
relative to other provinces.

We can describe these relationships by setting up a neighbourhood
structure based on queen contiguity where a pair of provinces are
considered neighbours if they share at least one point of boundary. This can be modelled as a Markov random field to generate an ICAR model with a spatially varying term. Each of these terms will be correlated the others according to the neighbourhood structure we have defined.

The Markov random field here follows a multivariate Gaussian
distribution. $\gamma_i$ is a vector of province effects having a
distribution with mean **0** and precision **P** where

$[\textbf{p}]_{ij} = v_i$ if $i=j$ and $v_i$ is the number of adjacent provinces
to province $i$,

$[\textbf{p}]_{ij} = -1$ if provinces $i$ and $j$ are adjacent, and

$[\textbf{p}]_{ij} = 0$ otherwise.

A further constraint that $\Sigma_j \gamma_j = 0$ is applied so that the
distribution is identifiable.

If we include an offset term (here, area) because we are more interested
in the incidence than in the actual count, then
\begin{equation}
log(\frac{\lambda_i} {\text{area}_i}) = \beta_0 + \beta_1x_i + \gamma_i
(\#eq:eq6)
\end{equation}
which is equivalent to
\begin{equation}
log(\lambda_i) = \beta_0 + \beta_1x_i + \gamma_i + log(\text{area}_i).
(\#eq:eq7)
\end{equation}
We are still modelling $log(\lambda)$ rather than the incidence, but we
are adding an offset to adjust for differing areas. Modelling $log(\lambda)$ and adding an offset is equivalent to
modelling incidence, and coefficients can be interpreted that way.

When interpreting the estimated coefficients of the model, it can be
useful to look at it in the following form:
\begin{equation}
\lambda_i = e^{\beta_0 + \beta_1 x_i + \gamma_i} \text{area}_i.
(\#eq:eq8)
\end{equation}

## Pre-functions

Such models, however, can not deal with locations which have no
neighbours. In the case of Indonesia, this is quite problematic. It is
composed of many islands. The estimated count of
islands according to @Andrfout2022 is 13,558.
While it is not unusual for a country to have a number of often small
offshore islands, Indonesia is entirely composed of (at least portions
of) an archipelago of islands, so many of these islands or groups of
islands are individual provinces in their own right. We might like them
to be associated with their k nearest neighbours. However, a nearest
neighbours approach to Indonesia as a whole might not be desired.
Therefore, they must either be excluded from the study or somehow
brought within the neighbourhood framework.

In this case, we use `st_bridges()` for setting up the queen contiguity
structure as usual, but with the additional stipulation that unconnected
units (provinces which are islands or collections of islands) are
considered neighbours to their *k* nearest provinces. For this example,
we have set the value of k to 2. The resulting neighbourhood structure
is shown in Figure \@ref(fig:`r ifelse(knitr::is_html_output(), 'ind-contig1html', 'ind-contig1')`).

(ref:my-caption1) Neighbourhood structure for Indonesian provinces created by `st_bridges()` with `k=2`. 

```{r, ind-contig1, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption1)"}
# join islands to k=2 nearest neighbours
# various arguments exist for altering colours and sizes
# additional ggplot themes and layers can be added

st_bridges(provinces_df, "province",link_islands_k = 2) |> 
  st_quickmap_nb(fillcol = "antiquewhite1", 
                 bordercol = "black", bordersize = 0.5, 
                 linkcol = "darkblue", linksize = 0.8, 
                 pointcol = "red", pointsize = 2) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()) +
  geom_sf(data=nearby_countries_df, 
          fill="gray50", linewidth=0.5, colour="black")

```

```{r, ind-contig1html, fig.width=12, fig.height=6, echo=FALSE, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Neighbourhood structure for Indonesian provinces created by st_bridges() with k=2. "}
# join islands to k=2 nearest neighbours
# various arguments exist for altering colours and sizes
# additional ggplot themes and layers can be added

st_bridges(provinces_df, "province",link_islands_k = 2) |> 
  st_quickmap_nb(fillcol = "antiquewhite1", 
                 bordercol = "black", bordersize = 0.5, 
                 linkcol = "darkblue", linksize = 0.8, 
                 pointcol = "red", pointsize = 2) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()) +
  geom_sf(data=nearby_countries_df, 
          fill="gray50", linewidth=0.5, colour="black")

```

This neighbourhood structure now has no unconnected provinces so it is
suitable for use in an ICAR model. However, we will

-   add some additional contiguities using `st_manual_join_nb()`

-   and remove one using `st_manual_cut_nb()`.

To cater for the possibility that a modeller might not be familiar with the names of the various geographic units but still wishes to make manual alterations to their relationships, we can look at a map (Figure \@ref(fig:`r ifelse(knitr::is_html_output(), 'ind-contig2html', 'ind-contig2')`)) where the nodes are shown by
index number instead of as points (using the argument `nodes='numeric'`). This makes it easy to manually cut
and join neighbours as desired. Furthermore, there is an option to
show concave hulls drawn around each unit (using `concavehull = TRUE`). This is also shown in Figure \@ref(fig:`r ifelse(knitr::is_html_output(), 'ind-contig2html', 'ind-contig2')`). These shapes are not used in the assignment of contiguities but it can be useful to see them in a situation such as Indonesia where many individual provinces are actually multipolygons. Without them, it is not clear whether an island is a province in its own right, or which group of islands together form one province.

(ref:my-caption2) Neighbourhood structure for Indonesian provinces. Viewed with `st_quickmap_nb()`, using the arguments `nodes = 'numeric'` and `concavehull = TRUE`. 

```{r, ind-contig2, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption2)"}
# with 'concavehull = TRUE' and 'nodes = "numeric"'

st_bridges(provinces_df, "province",link_islands_k = 2) |> 
  st_quickmap_nb(fillcol = "antiquewhite1", 
                 bordercol = "black", bordersize = 0.5, 
                 linkcol = "tomato", linksize = 0.5, 
                 nodes = "numeric", 
                 numericcol = "black", numericsize = 6, 
                 concavehull = TRUE, 
                 hullcol = "darkgreen", hullsize = 0.2) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank())

```

```{r, ind-contig2html, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Neighbourhood structure for Indonesian provinces. Viewed with st\\_quickmap_nb(), using the arguments nodes = 'numeric' and concavehull = TRUE. "}
# with 'concavehull = TRUE' and 'nodes = "numeric"'

st_bridges(provinces_df, "province",link_islands_k = 2) |> 
  st_quickmap_nb(fillcol = "antiquewhite1", 
                 bordercol = "black", bordersize = 0.5, 
                 linkcol = "tomato", linksize = 0.5, 
                 nodes = "numeric", 
                 numericcol = "black", numericsize = 6, 
                 concavehull = TRUE, 
                 hullcol = "darkgreen", hullsize = 0.2) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank())

```

Having made some manual adjustments to the neighbourhood structure, the
new structure can be seen in Figure \@ref(fig:`r ifelse(knitr::is_html_output(), 'ind-contig3html', 'ind-contig3')`). Edge effects
have also been mitigated by additionally connecting the two extreme
provinces (1 and 23), which would otherwise have only one neighbour, to
their two next closest neighbours.

(ref:my-caption3) Neighbourhood structure for Indonesian provinces, after alterations using `st_manual_join()` and `st_manual_cut()`. 

```{r, ind-contig3, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption3)"}
# a series of manual joins and cuts by index number

st_bridges(provinces_df, "province",link_islands_k = 2) |> 
  st_manual_join_nb(1,24) |> 
  st_manual_join_nb(1,30) |> 
  st_manual_join_nb(3,13) |> 
  st_manual_join_nb(13,17) |> 
  st_manual_join_nb(14,25) |> 
  st_manual_join_nb(20,29) |>
  st_manual_join_nb(19,23) |> 
  st_manual_join_nb(16,27) |> 
  st_manual_join_nb(22,23) |> 
  st_manual_join_nb(7,19) |> 
  st_manual_join_nb(7,20) |>
  st_manual_join_nb(19,28) |> 
  st_manual_join_nb(4,18) |> 
  st_manual_join_nb(21,26) |> 
  st_manual_join_nb(22,28) |> 
  st_manual_cut_nb(19,22) |> 
  st_quickmap_nb(fillcol = "antiquewhite1", 
                 bordercol = "black", bordersize = 0.5, 
                 linkcol = "darkblue", linksize = 0.8, 
                 pointcol = "red", pointsize = 2) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()) +
  geom_sf(data=nearby_countries_df, 
          fill="gray50", linewidth=0.5, colour="black") + 
  annotation_scale()

```

```{r, ind-contig3html, fig.width=12, fig.height=6, echo=FALSE, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Neighbourhood structure for Indonesian provinces, after alterations using st\\_manual_join() and st\\_manual_cut(). "}
# a series of manual joins and cuts by index number

st_bridges(provinces_df, "province",link_islands_k = 2) |> 
  st_manual_join_nb(1,24) |> 
  st_manual_join_nb(1,30) |> 
  st_manual_join_nb(3,13) |> 
  st_manual_join_nb(13,17) |> 
  st_manual_join_nb(14,25) |> 
  st_manual_join_nb(20,29) |>
  st_manual_join_nb(19,23) |> 
  st_manual_join_nb(16,27) |> 
  st_manual_join_nb(22,23) |> 
  st_manual_join_nb(7,19) |> 
  st_manual_join_nb(7,20) |>
  st_manual_join_nb(19,28) |> 
  st_manual_join_nb(4,18) |> 
  st_manual_join_nb(21,26) |> 
  st_manual_join_nb(22,28) |> 
  st_manual_cut_nb(19,22) |> 
  st_quickmap_nb(fillcol = "antiquewhite1", 
                 bordercol = "black", bordersize = 0.5, 
                 linkcol = "darkblue", linksize = 0.8, 
                 pointcol = "red", pointsize = 2) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()) +
  geom_sf(data=nearby_countries_df, 
          fill="gray50", linewidth=0.5, colour="black") + 
  annotation_scale()

```

## `mgcv` model

We now create the ICAR model using \CRANpkg{mgcv}. We will be able to simply pass
the contiguity structure we have created as both the data and a column
of it as the neighbourhood structure.

```{r, fig.width=12, fig.height=6}

provinces_df$province <- factor(provinces_df$province)

prep_data <- st_bridges(provinces_df, "province",link_islands_k = 2) |> 
  st_manual_join_nb(1,24) |> 
  st_manual_join_nb(1,30) |> 
  st_manual_join_nb(3,13) |> 
  st_manual_join_nb(13,17) |> 
  st_manual_join_nb(14,25) |> 
  st_manual_join_nb(20,29) |>
  st_manual_join_nb(19,23) |> 
  st_manual_join_nb(16,27) |> 
  st_manual_join_nb(22,23) |> 
  st_manual_join_nb(7,19) |> 
  st_manual_join_nb(7,20) |>
  st_manual_join_nb(19,28) |> 
  st_manual_join_nb(4,18) |> 
  st_manual_join_nb(21,26) |> 
  st_manual_join_nb(22,28) |> 
  st_manual_cut_nb(19,22)

```

```{r, echo=TRUE}

mod_pois_mrf <- gam(damaging_quakes_total ~ 
                      fault_concentration +
                      s(province, bs='mrf', xt=list(nb=prep_data$nb), k=22) +
                      offset(log(area_province)),
                    data=prep_data, method="REML",family = "poisson")

```

The adjusted R-squared is **0.957** and deviance explained is **88.2%**. The estimated coefficient associated with fault concentration is
-3.2355. As this is positive, it is greater than 1 when exponentiated:
$$
\text{exp}(0.7531) = 0.04
$$
and this is the expected multiplicative association between a unit
change in fault concentration and incidence of earthquakes in a
province.

Controlling for this estimated mean elevated risk of earthquakes due to
concentration of faults, what is the additional risk level of
earthquakes in a province? This can be seen as a measure of the activity
level of faults locally and it is spatially smoothed by the
autoregressive process. It is mapped as the ICAR component of the model
below:

```{r, eval=FALSE}

# these two are equivalent
AER::dispersiontest(mod_pois_mrf)
# AER::dispersiontest(mod_pois_mrf,trafo = 1)

# these two are equivalent
# AER::dispersiontest(mod_pois_mrf,trafo = function(x) x^2)
# AER::dispersiontest(mod_pois_mrf,trafo = 2)

```

## Post-functions

Use `st_augment()` to get estimates from \CRANpkg{mgcv} model in format
similar to that used by the \CRANpkg{broom} package. For instance, we see from the code below that the original dataframe is now augmented with columns for "mrf.smooth.province" and "mrf.smooth.province" which shows the estimate and standard errors for the $\gamma_i$ component. Note that this is how we would expect them to be named, based on the previous discussion surrounding Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:staugtab-html)', '\\@ref(tab:staugtab-latex)'))`.

```{r, echo=TRUE}
mod_pois_mrf |> 
  st_augment(prep_data) |> 
  names()
```

Use `st_augment()` and `st_quickmap_preds` in the following code to get a quick visualisation of
the estimates for $\gamma_i$, as shown in Figure \@ref(fig:`r ifelse(knitr::is_html_output(), 'ind-mrf1html', 'ind-mrf1')`). Again, note that the title and subtitle of the image are as previously discussed.

(ref:my-caption4) Estimates of $\gamma_i$ shown as a map using `st_quickmap_preds()`.

```{r, ind-mrf1, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption4)"}
# st_quickmap_preds() outputs a list of ggplots

plot_mrf <- mod_pois_mrf |> 
  st_augment(prep_data) |>
  st_quickmap_preds(scale_low = "darkgreen",
                    scale_mid = "ivory", 
                    scale_high = "darkred", 
                    scale_midpoint = 0)

# in this case, there is only one plot in the list
# so we call it by index

plot_mrf[[1]] +
  coord_sf(datum=NA) +
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()) +
  geom_sf(data=provinces_df, fill=NA, colour="black", linewidth=0.5) + 
  geom_sf(data=nearby_countries_df, fill="gray50", colour="black", 
          linewidth=0.5) + 
  labs(fill="relative\nincidence") +
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(legend.position = c(0.92,0.77),
        legend.box.background = element_rect(colour = "black", linewidth = 1),
        legend.title = element_text())

```

```{r, ind-mrf1html, fig.width=12, fig.height=6, echo=FALSE, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Estimates of $\\gamma_i$ using st_quickmap_preds(). "}
# st_quickmap_preds() outputs a list of ggplots

plot_mrf <- mod_pois_mrf |> 
  st_augment(prep_data) |>
  st_quickmap_preds(scale_low = "darkgreen",
                    scale_mid = "ivory", 
                    scale_high = "darkred", 
                    scale_midpoint = 0)

# in this case, there is only one plot in the list

plot_mrf[[1]] +
  coord_sf(datum=NA) +
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()) +
  geom_sf(data=provinces_df, fill=NA, colour="black", linewidth=0.5) + 
  geom_sf(data=nearby_countries_df, fill="gray50", colour="black", 
          linewidth=0.5) + 
  labs(fill="relative\nincidence") +
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(legend.position = c(0.92,0.77),
        legend.box.background = element_rect(colour = "black", linewidth = 1),
        legend.title = element_text())

```

If we wish to apply the inverse link function (the exponential function in the case of this poisson model) to map these values to a more interpretable scale, this will not be generated by the function `st_quickmap_preds()`. Instead, we must use the augmented dataframe which is produced by `st_augment()` and create the appropriate extra column with the usual \CRANpkg{tidyverse} `mutate()` function. This allows us to produce the map in Figure
\@ref(fig:`r ifelse(knitr::is_html_output(), 'ind-mrf2html', 'ind-mrf2')`). As these coefficients are multiplicatively related
to the earthquake incidence, values below 1 imply an earthquake
incidence which is lower than expected.

The provinces with the 3 most elevated incidences are labelled in red
We can see that, controlling for the added risk of proximity to
faults, the province of Aceh has 7.9 times the expected
incidence, or number of major earthquakes per square kilometre. The two
lowest-scoring provinces, labelled in green, have essentially no incidence of
earthquake epicentres, controlling for what their proximity to faults alone would
suggest.

(ref:my-caption5) Map showing estimates of $\text{exp}(\gamma_i).$ This is produced by adding an additional column to the dataframe produced by `st_augment()`.

```{r, ind-mrf2, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption5)"}

qpois_mod_aug <- mod_pois_mrf |> 
  st_augment(prep_data)

largest <- qpois_mod_aug |> 
  arrange(desc(mrf.smooth.province)) |> 
  head(3)
smallest <- qpois_mod_aug |> 
  arrange(mrf.smooth.province) |> 
  head(2)

ggplot() + 
  geom_sf(data=nearby_countries_df, 
          fill="gray50", colour="black", linewidth=0.5) + 
  geom_sf(data=qpois_mod_aug, aes(fill=exp(mrf.smooth.province)), 
          colour="black", linewidth=0.5) + 
  geom_sf_label_repel(data=largest, 
                      aes(label=paste(province,":",
                                      round(exp(mrf.smooth.province),1))),
                      colour="darkred", size=2.5,
                      nudge_y= 300000) +
  geom_sf_label_repel(data=smallest |> mutate(geometry=st_centroid(geometry)), 
               aes(label=paste(province,":",round(exp(mrf.smooth.province),3))),
               nudge_y= 200000, colour="darkgreen", size=2.5) +
  scale_fill_gradient2(low = "darkgreen", 
                       mid = "ivory", 
                       high = "darkred", 
                       midpoint = 1) +
  scale_colour_gradient2(low = "darkgreen", 
                         mid = "ivory", 
                         high = "darkred", 
                         midpoint = 1) +
  guides(colour="none") + 
  labs(fill="exp.\nrelative\nincidence") + 
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5), 
        axis.title = element_blank(),
        axis.ticks = element_blank(), 
        legend.position = c(0.92,0.76),
        legend.box.background = element_rect(colour = "black", linewidth = 1))

```

```{r, ind-mrf2html, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Map showing estimates of exp($\\gamma_i$). This is produced by adding an additional column to the dataframe produced by st_augment()."}

qpois_mod_aug <- mod_pois_mrf |> 
  st_augment(prep_data)

largest <- qpois_mod_aug |> 
  arrange(desc(mrf.smooth.province)) |> 
  head(3)
smallest <- qpois_mod_aug |> 
  arrange(mrf.smooth.province) |> 
  head(2)

ggplot() + 
  geom_sf(data=nearby_countries_df, 
          fill="gray50", colour="black", linewidth=0.5) + 
  geom_sf(data=qpois_mod_aug, aes(fill=exp(mrf.smooth.province)), 
          colour="black", linewidth=0.5) + 
  geom_sf_label_repel(data=largest, 
                      aes(label=paste(province,":",
                                      round(exp(mrf.smooth.province),1))),
                      colour="darkred", size=2.5,
                      nudge_y= 300000) +
  geom_sf_label_repel(data=smallest |> mutate(geometry=st_centroid(geometry)), 
               aes(label=paste(province,":",round(exp(mrf.smooth.province),3))),
               nudge_y= 200000, colour="darkgreen", size=2.5) +
  scale_fill_gradient2(low = "darkgreen", 
                       mid = "ivory", 
                       high = "darkred", 
                       midpoint = 1) +
  scale_colour_gradient2(low = "darkgreen", 
                         mid = "ivory", 
                         high = "darkred", 
                         midpoint = 1) +
  guides(colour="none") + 
  labs(fill="exp.\nrelative\nincidence") + 
  annotation_scale() +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#ECF6F7", colour = "black", linewidth=1.5), 
        axis.title = element_blank(),
        axis.ticks = element_blank(), 
        legend.position = c(0.92,0.76),
        legend.box.background = element_rect(colour = "black", linewidth = 1))

```

## Workflow

In this example, we have gone through a number of stages carefully, making changes to contiguities that we deemed appropriate as we went. However, in practice, at least in a first iteration, it might not be necessary to go through all of these steps. A rough and ready model (and visual output) can be generated with `sfislands` using nothing more than three or four lines of code, such as the following:

```{r, eval=FALSE, echo=TRUE}
# set up neighbourhood structure

prep_data <- st_bridges(provinces_df, "province")

# define model

mod <- gam(quake_mlxl_total ~ 
                  fault_concentration +
                  s(province, bs='mrf', xt=list(nb=prep_data$nb), k=22) +
                  offset(log(area_province)),
        data=prep_data, method="REML",family = "poisson")

# augment tidy estimates

tidy_ests <- st_augment(mod, prep_data)

# visualise them

st_quickmap_preds(tidy_ests)
```

# Example 2: London

The next example looks only at using the *pre-functions*, but in a situation where the presence of islands is not the issue. Consider the wards and boroughs of London (sourced from the Greater London Authority's [London Datastore](https://data.london.gov.uk/)). In Figure \@ref(fig:lon-contig1) the `st_bridges()`
function is applied to them to construct a queen contiguity
neighbourhood structure. Because there are no disjoint units (or
"islands"), this will be the same as using `st_contiguity()` from
\CRANpkg{sfdep}. The `st_quickmap_nb()` function gives an immediate
visual representation of the structure. This can be supplemented by
adding a layer showing the course of the river Thames.

```{r, lon-contig1, fig.width=12, fig.height=8, echo=TRUE, out.width="100%", fig.cap = "Wards and boroughs of Greater London. Queen contiguity. "}
# same as sfdep:st_contiguity() as there are no islands
# an extra layer for the river Thames

st_bridges(london, "NAME") |> 
  st_quickmap_nb() + 
  geom_sf(data=thames, colour="blue", linewidth=1.5) + 
  theme(panel.background = element_rect(fill = "#F6F3E9", colour = "black", 
                                        linewidth=1.5))

```

When the study area has a river running through it there can be problems
with constructing neighbourhood structures. Depending on how the
geometries are defined, the presence of a river can either mean that no
units on either side of its banks are considered neighbours or, at the
other extreme, the river is essentially ignored and all units on
opposing banks are considered neighbours.

Depending on the presence of river crossings, two areas which are
physically quite close might be very distinct. Somebody living on the
banks of a river might be more likely to go about their life primarily
on their side of the river, despite the short distance as the crow flies
of facilities on the other side.

`sfislands` makes it easier to take account of this situation. We can look
at just those boroughs which are on either side of the river Thames (Figure
\@ref(fig:lon-contig2))

```{r, lon-contig2, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", fig.cap = "Riverside boroughs of Greater London. Queen contiguity disregarding river. "}
# which boroughs are alongside the river

riverside <- thames |> st_intersects(london) |> unlist() |> unique()

# only map these boroughs

st_bridges(london[riverside,],"NAME") |> 
  st_quickmap_nb(linksize = 0.5) +
  geom_sf(data=thames, colour="blue", linewidth=1.5) + 
  annotation_scale(location="br") +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F6F3E9", colour = "black", 
                                        linewidth=1.5))
```

In order to take account of actual connectivity, we can add a layer
showing the road and pedestrian bridges or tunnels. These were scraped from a Wikipedia article describing the various crossings of the river Thames. In Figure \@ref(fig:lon-crossings), we
have also drawn a 1 kilometre buffer around them. Until we get to the
eastern portion of the map, all units on opposing sides of the river are
within 1 kilometre of a crossing. This is not the case for the extreme
eastern units so we might not want to consider these units neighbours if
the river flows between them.

```{r, lon-crossings, fig.width=12, fig.height=6, out.width="100%", fig.cap = "Riverside boroughs of Greater London. Road and pedestrian crossing and tunnels surrounded by 1 kilometre buffer shaded green. "}

ggplot() + 
  geom_sf(data=london[riverside,], fill="gray90", colour="gray50", linewidth=0.5) + 
  geom_sf(data=crossings_roadped |> st_buffer(1000), fill="darkgreen", alpha=0.4) + 
  geom_sf(data=thames, colour="blue", linewidth=1.5) + 
  geom_sf(data=crossings_roadped, size=1, colour="yellow") + 
  geom_sf_label_repel(data=crossings_roadped[1:11,], aes(label=crossing), size=2.5, nudge_y=-10000, fill="white", fontface="bold") + 
  geom_sf_label_repel(data=crossings_roadped[12:22,], aes(label=crossing), size=2.5, nudge_y=10000, fill="white", fontface="bold") +
  annotation_scale(location="br") +
  coord_sf(datum=NA)

```

```{r}
# which riverside units do not fall within any of the buffers...

crossing_buffer_summarised <- crossings_roadped |> 
  st_buffer(1000) |> 
  st_transform(st_crs(london)) |> 
  summarise()

touch_buffer <- st_intersects(london[riverside,],
                              crossing_buffer_summarised)
indices <- c()
for (i in seq_along(touch_buffer)) {
  if (length(touch_buffer[[i]]) == 0) {
    indices <- c(indices, i)
  }
}
indices <- which(sapply(touch_buffer, length) == 0)

no_touch_buffer <- london[riverside,][indices,]
```

In order the identify the changes we wish to make, we use the
`nodes = "numeric"` argument in `st_quickmap_nb()`. Now we can identify
each unit by its position in the contiguity structure. Here we have
shaded in pink the units which are not within 1 kilometre of a river
crossing (see Figure \@ref(fig:lon-contig3)).

```{r, lon-contig3, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", fig.cap = "Riverside boroughs of Greater London. Index number for each borough shown at centroid. Boroughs which are not within 1 kilometre of a crossing are shaded pink. "}
# with 'nodes = "numeric"'

st_bridges(london[riverside,],"NAME") |> 
  st_quickmap_nb(nodes = "numeric", numericsize = 4, linksize = 0.5) +
  geom_sf(data=no_touch_buffer, fill="pink", alpha=0.3) + 
  geom_sf(data=crossings_roadped |> st_buffer(1000), 
          fill="darkgreen", alpha=0.3) +
  geom_sf(data=thames, colour="blue", linewidth=1.5) + 
  geom_sf(data=crossings_roadped, size=1, colour="yellow") + 
  annotation_scale(location="br") +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F6F3E9", colour = "black", 
                                        linewidth=1.5))
```

This allows us to easily cut the ties across the river for these units
manually by using the function `st_manual_cut_nb()`. The results of this editing procedure are shown in Figure \@ref(fig:lon-contig4).
While we are using the index of the units in this example, the function also
accepts names as arguments which may be more convenient in some circumstances. Having made these adjustments,
`st_quickmap_nb()` now shows a connectivity structure (Figure \@ref(fig:lon-contig4)) which reflects the influence of the
presence or absence of river crossings.

This example shows that the pre-functions of `sfislands` have uses for situations which do not involve islands. They can be used to apply domain knowledge to easily design the most appropriate neighbourhood structure.

```{r, lon-contig4, fig.width=12, fig.height=6, echo=TRUE, out.width="100%", fig.cap = "Riverside boroughs of Greater London. Contiguities across the river have been cut for the pink boroughs. "}
# manually cut the links where there is no crossing

st_bridges(london[riverside,],"NAME") |> 
  st_manual_cut_nb(18,17) |> 
  st_manual_cut_nb(19,17) |> 
  st_manual_cut_nb(19,20) |> 
  st_manual_cut_nb(20,21) |> 
  st_manual_cut_nb(21,22) |> 
  st_manual_cut_nb(22,48) |> 
  st_manual_cut_nb(47,48) |> 
  st_manual_cut_nb(45,46) |> 
  st_manual_cut_nb(45,47) |>  
  st_manual_cut_nb(39,65) |> 
  st_manual_cut_nb(1,2) |> 
  st_quickmap_nb(bordercol = "black", bordersize = 0.5, linksize = 0.5) +
  geom_sf(data=no_touch_buffer, fill="pink", alpha=0.3) + 
  geom_sf(data=crossings_roadped |> st_buffer(1000), 
          fill="darkgreen", alpha=0.3) +
  geom_sf(data=thames, colour="blue", linewidth=1.5) +
  annotation_scale(location="br") +
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F6F3E9", colour = "black", 
                                        linewidth=1.5))
```

# Example 3: Liverpool

In this final example, there are no islands or river issues. We saw in the Indonesia example how `sfislands` can extract estimates from the `mgcv` argument `bs="mrf"`. It can also deal with random effects as defined by `bs="re"` in `mgcv` models. Here, we
will construct a hierarchical model in this way which also features an ICAR component. We will
compare two different types of contiguity which could be applied:

* `st_bridges()` from `sfislands`, and 
* `st_knn()` from \CRANpkg{sfdep}. 

We will show how their outcomes can be quickly mapped to give an immediate sense of the differences.

```{r}
livadmin <- tribble(
  ~code, ~`area type`, ~description,
  "OA", "output areas", "lowest level of geographical area for census statistics, usually containing 100 - 625 persons",
  "LSOA", "lower layer super output areas", "usually 4 or 5 OAs",
  "MSOA", "middle layer super output areas", "usually 4 or 5 LSOAs"
)

```

```{r livadmin-html, eval = knitr::is_html_output(), layout = "center"}
knitr::kable(livadmin, format = "html", caption = "Three nested levels of administrative divisions in Liverpool.") |> 
  kable_styling(full_width = TRUE)
```

```{r livadmin-latex, eval = knitr::is_latex_output()}
knitr::kable(livadmin, format = "latex", caption = "Three nested levels of administrative divisions in Liverpool.") |> 
  kableExtra::kable_styling(font_size = 8) |> 
  column_spec(3, width = "7cm")
```   

```{r, liv-nested, fig.width=10, fig.height=5, out.width="100%", fig.cap = "Nested levels of administrative divisions in Liverpool. "}

ggarrange(
  ggplot() + 
    geom_sf(data=msoa_sf, fill="gray90", colour="black") +  
    geom_sf(data=mersey, fill="lightblue", colour="black", linewidth=0.2) + 
    geom_sf(data=liverpool |> summarise(), colour="black", fill=NA) + 
    labs(title = "level 1: MSOA polygons") + 
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F7FFF2", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()),
  
  ggplot() + 
    geom_sf(data=lsoa_sf, fill="gray90", colour="gray40") +  
    geom_sf(data=mersey, fill="lightblue", colour="black", linewidth=0.2) + 
    geom_sf(data=liverpool |> summarise(), colour="black", fill=NA) + 
    labs(title = "level 2: LSOA polygons") + 
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F7FFF2", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()),
  
  ggplot() + 
    geom_sf(data=liverpool |> summarise(), colour="black", fill="white") + 
    geom_sf(data=liverpool |> st_centroid(), 
            fill="gray90", colour="gray50", size=0.1) +  
    geom_sf(data=mersey, fill="lightblue", colour="black", linewidth=0.2) + 
    labs(title = "level 3: OA (shown as centroids)") + 
  coord_sf(datum=NA) + 
  theme(panel.background = element_rect(fill = "#F7FFF2", colour = "black", 
                                        linewidth=1.5),
        axis.text = element_blank()),
  
  ncol=3
)

```

```{r, liv-vars, fig.width=6, fig.height=4, out.width="70%", fig.cap = "Unemployment and limiting long-term illness rates in Liverpool, with extent of Mersey estuary in light blue to the south west. "}

ggarrange(
  ggplot() + 
    geom_sf(data=liverpool, aes(fill=unemployment, colour=unemployment)) + 
    geom_sf(data=liverpool |> summarise(), 
            fill=NA, colour="gray30", linewidth=0.2) +  
    geom_sf(data=mersey, fill="lightblue", colour="gray30", linewidth=0.2) + 
    scale_fill_distiller(palette = "PuBu", direction = 1) + 
    scale_colour_distiller(palette = "PuBu", direction = 1) + 
    labs(fill="unemployment",
         colour="unemployment") + 
    coord_sf(datum=NA) + 
    annotation_scale(location = "bl", width_hint = 0.4) +
    annotation_north_arrow(location = "bl", which_north = "true", 
        pad_x = unit(0.0, "in"), pad_y = unit(0.2, "in"),
        style = north_arrow_fancy_orienteering) +
    theme(panel.background = element_rect(fill = "#F7FFF2", colour = "black", 
                                          linewidth=0.6), 
          axis.title = element_blank(),
          axis.ticks = element_blank(),
          legend.text = element_text(size=8),
          legend.title = element_text(size=8)),
  ggplot() + 
    geom_sf(data=liverpool, aes(fill=lt_illness, colour=lt_illness)) + 
    geom_sf(data=liverpool |> summarise(), 
            fill=NA, colour="gray30", linewidth=0.2) +  
    geom_sf(data=mersey, fill="lightblue", colour="gray30", linewidth=0.2) + 
    scale_fill_distiller(palette = "RdYlBu", direction = -1) + 
    scale_colour_distiller(palette = "RdYlBu", direction = -1) + 
    labs(fill="limiting long-term\nillness\n(z-score)",
         colour="limiting long-term\nillness\n(z-score)") + 
    coord_sf(datum=NA) +
    annotation_scale(location = "bl", width_hint = 0.4) +
    annotation_north_arrow(location = "bl", which_north = "true", 
        pad_x = unit(0.0, "in"), pad_y = unit(0.2, "in"),
        style = north_arrow_fancy_orienteering) +
    theme(panel.background = element_rect(fill = "#F7FFF2", colour = "black", 
                                          linewidth=0.6), 
          axis.title = element_blank(),
          axis.ticks = element_blank(),
          legend.text = element_text(size=8),
          legend.title = element_text(size=8)),
  
  ncol=2, legend = "bottom"
)

```

```{r, liv-contigs, fig.width=5, fig.height=5, out.width="60%", echo=TRUE, fig.cap = "First order queen contiguity of output areas (OAs) in Liverpool with magnified inset. "}
# magnify a section

from <- c(xmin = -2.97, xmax = -2.95, ymin = 53.38, ymax = 53.39)
to <- c(-3.01,-2.96,53.32,53.35)

st_bridges(liverpool, "oa_cd") |> 
  st_quickmap_nb(pointsize = 0.1,
                 linksize = 0.1,
                 fillcol = "gray90") +  
  geom_sf(data=mersey, fill="lightblue", colour="gray30", 
          linewidth=0.2, alpha=0.5) + 
  geom_magnify(data=liverpool, 
               from = from, to = to, 
               corners = 0.1, shadow = TRUE, linewidth = 0.6) + 
  theme(panel.background = element_rect(fill = "#F7FFF2",
                                        colour = "black", linewidth=1))

```

```{r}

# these models take a while to run
# so i am using a saved version of their output
# the files are large so are not on github
# uncomment the model and run it to reproduce

prepliv <- st_bridges(liverpool, "oa_cd")

# liverpool_model2 <- gam(unemployment ~ lt_illness + 
#                          s(msoa_cd, bs="re") + 
#                          s(msoa_cd, lt_illness, bs="re") +
#                          s(lsoa_cd, bs="re") + 
#                          s(lsoa_cd, lt_illness, bs="re"), # ICAR constituency ICAR varying coefficients
#                        data=prepliv, method="REML")

# saveRDS(liverpool_model2, here("data","liverpool_model2.rds"))

liverpool_hmodel <- readRDS(here("data","liverpool_model2.rds"))

# summary(liverpool_hmodel)

```

```{r}

# these models take a while to run
# so i am using a saved version of their output
# the files are large so are not on github
# uncomment the model and run it to reproduce

# liverpool_hsamodel <- gam(unemployment ~ lt_illness +
#                          s(msoa_cd, bs="re") +
#                          s(msoa_cd, lt_illness, bs="re") +
#                          s(lsoa_cd, bs="re") +
#                          s(lsoa_cd, lt_illness, bs="re") +
#                          s(oa_cd, bs='mrf',
#                            xt=list(nb=prepliv$nb),k=20), # ICAR constituency ICAR varying coefficients
#                        data=prepliv, method="REML")

# saveRDS(liverpool_hsamodel, here("data","liverpool_hsamodel.rds")

liverpool_hsamodel <- readRDS(here("data","liverpool_hsamodel.rds"))

# summary(liverpool_hsamodel)

```

```{r}

liverpool_hmodel_aug <- liverpool_hmodel |> 
  st_augment(prepliv) # pipe into function to get estimates

liverpool_hsamodel_aug <- liverpool_hsamodel |> 
  st_augment(prepliv) # pipe into function to get estimates

```

```{r}

liverpool_hmodel_plots <- liverpool_hmodel |> 
  st_augment(prepliv) |> # pipe into function to get estimates
  st_quickmap_preds(borderwidth = NA, 
                    scale_low = "darkblue",
                    scale_mid = "gray75",
                    scale_high = "darkred",
                    scale_midpoint = 0, 
                    framefill = "#F7FFF2",
                    frameline = "black",
                    framesize = 1) # pipe into this for visualisation

```

This example is based on data from the [Office of National Statistics](https://www.nomisweb.co.uk/home/census2001.asp) as presented by @liverpool-notes in their demonstration of techniques for hierarchical spatial regression. They use the different levels of nested administrative boundaries in Liverpool for their demonstration. These are described in Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:livadmin-html)', '\\@ref(tab:livadmin-latex)'))`, and are mapped separately in Figure \@ref(fig:liv-nested).

Now suppose we wish to model unemployment as a function of limited long-term
illness, taking into account this hierarchical structure. Limiting long-term illness (LLTI) refers to a health problem or disability which limits a person's day-to-day activities [@Barnett2001]. We wish to incorporate a fixed intercept and coefficient for LLTI, with additional random intercepts and slopes at MSOA and LSOA levels. The
distribution of these variables across the OAs of Liverpool are shown in Figure
\@ref(fig:liv-vars).

If $y_{ijk}$ and $x_{ijk}$ are respectively the levels of unemployment and LLTI in each of $i$ OAs within $j$ LSOAs, which in turn are within $k$ MSOAs, then 
\begin{equation}
y_{ijk} = \beta_{0jk} + \beta_{1jk}x_{ijk} + \gamma_{ijk} + \epsilon_{ijk}
(\#eq:eq9)
\end{equation}
\begin{equation}
\beta_{0jk} = \beta_{0k} + u_{0jk}
(\#eq:eq10)
\end{equation}
\begin{equation}
\beta_{1jk} = \beta_{1k} + u_{1jk}
(\#eq:eq11)
\end{equation}
\begin{equation}
\beta_{0k} = \beta_0 + w_{0k}
(\#eq:eq12)
\end{equation}
\begin{equation}
\beta_{1k} = \beta_1 + w_{1k}
(\#eq:eq13)
\end{equation}
\begin{equation}
\epsilon_{ijk} \sim N(0,\sigma_{\epsilon}^2)
(\#eq:eq14)
\end{equation}
\begin{equation}
u_{jk} \sim N(0,\sigma_{u}^2)
(\#eq:eq15)
\end{equation}
\begin{equation}
 w_{k} \sim N(0,\sigma_{w}^2)
(\#eq:eq16)
\end{equation}
where the $\gamma_{ijk}$s comprise a vector of ICAR components for each OA, similar to the provinces in the earlier Indonesia model. The vector has a multivariate normal distribution with mean 0 and precision related to the contiguity structure as before.

There are no islands or discontiguities in this geometry of Liverpool so
using `st_bridges()` will give the same structure as would
`sfdep::st_contiguity()` (see Figure \@ref(fig:liv-contigs)).

The hierarchical model with no mrf component produces estimates as shown
in Figure \@ref(fig:liv-est1).

```{r, liv-est1, fig.width=12, fig.height=3, out.width="100%", fig.cap = "Random intercept and slope estimates from hierarchical model. Middle and lower layer super output areas as levels. "}
# put an empty plot on the right to line up with those with an extra lowest level

ggarrange(
  plotlist = liverpool_hmodel_plots,
  nrow = 1, legend = "right"
)

```

```{r}

liverpool_hsamodel_plots <- liverpool_hsamodel |> 
  st_augment(prepliv) |> # pipe into function to get estimates
  st_quickmap_preds(borderwidth = NA, 
                    # legendlimits = "minmax",
                    scale_low = "darkblue",
                    scale_mid = "gray75",
                    scale_high = "darkred",
                    scale_midpoint = 0, 
                    framefill = "#F7FFF2",
                    frameline = "black",
                    framesize = 1) # pipe into this for visualisation

```

If we instead use contiguity as the basis of an additional spatial term,
we get estimates shown in Figure \@ref(fig:`r ifelse(knitr::is_html_output(), 'liv-est2html', 'liv-est2')`).

(ref:my-caption6) Random intercept and slope estimates from hierarchical model. Middle and lower layer super output areas are the top two levels respectively (MSOA & LSOA). Output areas (OA) as lowest level Markov random field smooth using first-degree queen contiguity from `st_bridges()`. 

```{r, liv-est2, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption6)"}

ggarrange(
  ggarrange(
    liverpool_hsamodel_plots[[1]],
    liverpool_hsamodel_plots[[2]],
    liverpool_hsamodel_plots[[3]],
    liverpool_hsamodel_plots[[4]],
    nrow = 1
  ),
  liverpool_hsamodel_plots[[5]],
  nrow = 2
)

```

```{r, liv-est2html, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Random intercept and slope estimates from hierarchical model. Middle and lower layer super output areas are the top two levels respectively (MSOA & LSOA). Output areas (OA) as lowest level Markov random field smooth using first-degree queen contiguity from st\\_bridges(). "}

ggarrange(
  ggarrange(
    liverpool_hsamodel_plots[[1]],
    liverpool_hsamodel_plots[[2]],
    liverpool_hsamodel_plots[[3]],
    liverpool_hsamodel_plots[[4]],
    nrow = 1
  ),
  liverpool_hsamodel_plots[[5]],
  nrow = 2
)

```

```{r}

# 0.7km distance band
prepliv <- liverpool |> 
  mutate(nb = st_centroid(liverpool) |> 
              st_dist_band(upper = 0.7))
names(prepliv$nb) <- prepliv$oa_cd

# these models take a while to run
# so i am using a saved version of their output
# the files are large so are not on github
# uncomment the model and run it to reproduce

# liverpool_hsamodel_dist_band <- gam(unemployment ~ lt_illness +
#                          s(msoa_cd, bs="re") +
#                          s(msoa_cd, lt_illness, bs="re") +
#                          s(lsoa_cd, bs="re") +
#                          s(lsoa_cd, lt_illness, bs="re") +
#                          s(oa_cd, bs='mrf',
#                            xt=list(nb=prepliv$nb),k=20), # ICAR constituency ICAR varying coefficients
#                        data=prepliv, method="REML")

# saveRDS(liverpool_hsamodel_dist_band, here("data","liverpool_hsamodel_dist_band.rds"))

liverpool_hsamodel_dist_band <- readRDS(here("data","liverpool_hsamodel_dist_band.rds"))

# summary(liverpool_hsamodel_dist_band)

```

```{r}

liverpool_hsamodel_dist_band_plots <- liverpool_hsamodel_dist_band |> 
  st_augment(prepliv) |> # pipe into function to get estimates
  st_quickmap_preds(borderwidth = NA, 
                    scale_low = "darkblue",
                    scale_mid = "gray75",
                    scale_high = "darkred",
                    scale_midpoint = 0, 
                    framefill = "#F7FFF2",
                    frameline = "black",
                    framesize = 1) # pipe into this for visualisation

```

If instead we consider units to be neighbours if they lie within a
distance band of 700 metres, we get estimates shown in Figure
\@ref(fig:`r ifelse(knitr::is_html_output(), 'liv-est3html', 'liv-est3')`).

A comparison of their AICs (see Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:aic-html)', '\\@ref(tab:aic-latex)'))`) suggests that, in this scenario, queen contiguity is more appropriate than the distance band condition.

(ref:my-caption7) Random intercept and slope estimates from hierarchical model. Middle and lower layer super output areas are the top two levels respectively (MSOA & LSOA). Output areas (OA) as lowest level Markov random field smooth using `sfdep::st_dist_band()` with radius of 700 metres. 

```{r, liv-est3, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_latex_output(), fig.cap = "(ref:my-caption7)"}

ggarrange(
  ggarrange(
    liverpool_hsamodel_dist_band_plots[[1]],
    liverpool_hsamodel_dist_band_plots[[2]],
    liverpool_hsamodel_dist_band_plots[[3]],
    liverpool_hsamodel_dist_band_plots[[4]],
    nrow = 1
  ),
  liverpool_hsamodel_dist_band_plots[[5]],
  nrow = 2
)

```

```{r, liv-est3html, fig.width=12, fig.height=6, out.width="100%", eval=knitr::is_html_output(), fig.cap = "Random intercept and slope estimates from hierarchical model. Middle and lower layer super output areas are the top two levels respectively (MSOA & LSOA). Output areas (OA) as lowest level Markov random field smooth using sfdep\\:\\:st\\_dist_band() with radius of 700 metres."}

ggarrange(
  ggarrange(
    liverpool_hsamodel_dist_band_plots[[1]],
    liverpool_hsamodel_dist_band_plots[[2]],
    liverpool_hsamodel_dist_band_plots[[3]],
    liverpool_hsamodel_dist_band_plots[[4]],
    nrow = 1
  ),
  liverpool_hsamodel_dist_band_plots[[5]],
  nrow = 2
)

```

```{r}

aic_tab <- AIC(liverpool_hmodel, liverpool_hsamodel, liverpool_hsamodel_dist_band) |> 
  data.frame() |> 
  mutate(`relative AIC` = round(-AIC / min(AIC),3),
         model = c("hierachical model, no ICAR",
                   "hierachical model, ICAR based on st_bridges()",
                   "hierachical model, ICAR based on sfdep::st_dist_band()")) |> 
  rownames_to_column(var="modcode") |> 
  arrange(AIC) |> 
  select(model, AIC, `relative AIC`)

```

```{r aic-html, eval = knitr::is_html_output(), layout = "center"}
knitr::kable(aic_tab, format = "html", caption = "Comparison of models by AIC.") |> 
  kable_styling(full_width = TRUE)
```

```{r aic-latex, eval = knitr::is_latex_output()}
knitr::kable(aic_tab, format = "latex", caption = "Comparison of models by AIC.") |> 
  kableExtra::kable_styling(font_size = 8)
```   

# Summary

These examples have shown the varying scenarios in which `sfislands` can be useful. It aims to contribute to spatial modelling by making an awkward area less awkward. Rather than having a default attitude of ignoring islands when building neighbourhood structures based on contiguity, it hopes to encourage at least an examination of whether or not it is appropriate for them to be included. It also provides helper functions to use these structures in spatial regression models built with `mgcv` which streamline the human effort necessary to examine the estimates.

# Acknowledgements

This publication has emanated from research conducted with the financial support of Science Foundation Ireland under Grant number 18/CRT/6049.
